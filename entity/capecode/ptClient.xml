<?xml version="1.0" standalone="no"?>
<!DOCTYPE entity PUBLIC "-//UC Berkeley//DTD MoML 1//EN"
    "http://ptolemy.eecs.berkeley.edu/xml/dtd/MoML_1.dtd">
<entity name="ptClient" class="ptolemy.actor.TypedCompositeActor">
    <property name="_createdBy" class="ptolemy.kernel.attributes.VersionAttribute" value="11.0.devel">
    </property>
    <property name="DE Director" class="ptolemy.domains.de.kernel.DEDirector">
        <property name="stopTime" class="ptolemy.data.expr.Parameter" value="7.0">
        </property>
        <property name="stopWhenQueueIsEmpty" class="ptolemy.data.expr.Parameter" value="false">
        </property>
        <property name="synchronizeToRealTime" class="ptolemy.data.expr.Parameter" value="true">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[110.0, 240.0]">
        </property>
    </property>
    <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={206, 154, 1440, 632}, maximized=true}">
    </property>
    <property name="_vergilSize" class="ptolemy.actor.gui.SizeAttribute" value="[1206, 522]">
    </property>
    <property name="_vergilZoomFactor" class="ptolemy.data.expr.ExpertParameter" value="1.6693454920590445">
    </property>
    <property name="_vergilCenter" class="ptolemy.data.expr.ExpertParameter" value="{394.99545907974243, 222.646484375}">
    </property>
    <property name="PROJECT_PATH" class="ptolemy.data.expr.Parameter" value="&quot;/Users/hokeunkim/Development/iotauth/&quot;">
        <property name="_hideName" class="ptolemy.kernel.util.SingletonAttribute">
        </property>
        <property name="_icon" class="ptolemy.vergil.icon.ValueIcon">
            <property name="_color" class="ptolemy.actor.gui.ColorAttribute" value="{0.0, 0.0, 1.0, 1.0}">
            </property>
        </property>
        <property name="_smallIconDescription" class="ptolemy.kernel.util.SingletonConfigurableAttribute">
            <configure>
      <svg>
        <text x="20" style="font-size:14; font-family:SansSerif; fill:blue" y="20">-P-</text>
      </svg>
    </configure>
        </property>
        <property name="_editorFactory" class="ptolemy.vergil.toolbox.VisibleParameterEditorFactory">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[45.0, 280.0]">
        </property>
    </property>
    <entity name="SingleEvent" class="ptolemy.actor.lib.SingleEvent">
        <property name="_location" class="ptolemy.kernel.util.Location" value="[90.0, 105.0]">
        </property>
        <property name="_hideName" class="ptolemy.data.expr.SingletonParameter" value="false">
        </property>
    </entity>
    <entity name="Const" class="ptolemy.actor.lib.Const">
        <property name="value" class="ptolemy.data.expr.Parameter" value="{group=&quot;PtServers&quot;}">
        </property>
        <property name="_icon" class="ptolemy.vergil.icon.BoxedValueIcon">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="value">
            </property>
            <property name="displayWidth" class="ptolemy.data.expr.Parameter" value="40">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[225.0, 105.0]">
        </property>
        <property name="_hideName" class="ptolemy.data.expr.SingletonParameter" value="true">
        </property>
    </entity>
    <entity name="MicrostepDelay" class="ptolemy.actor.lib.MicrostepDelay">
        <property name="_location" class="ptolemy.kernel.util.Location" value="[635.0, 155.0]">
        </property>
        <property name="_hideName" class="ptolemy.data.expr.SingletonParameter" value="true">
        </property>
        <property name="_rotatePorts" class="ptolemy.data.expr.Parameter" value="90">
        </property>
    </entity>
    <entity name="Const2" class="ptolemy.actor.lib.Const">
        <property name="value" class="ptolemy.data.expr.Parameter" value="&quot;Message from ptClient: &quot;">
        </property>
        <property name="_icon" class="ptolemy.vergil.icon.BoxedValueIcon">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="value">
            </property>
            <property name="displayWidth" class="ptolemy.data.expr.Parameter" value="40">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[630.0, 220.0]">
        </property>
        <property name="_flipPortsHorizontal" class="ptolemy.data.expr.Parameter" value="true">
        </property>
        <property name="_hideName" class="ptolemy.data.expr.SingletonParameter" value="true">
        </property>
    </entity>
    <entity name="DiscreteClock" class="ptolemy.actor.lib.DiscreteClock">
        <property name="stopTime" class="ptolemy.data.expr.Parameter" value="1.9">
        </property>
        <property name="period" class="ptolemy.actor.parameters.PortParameter" value="0.5">
        </property>
        <property name="values" class="ptolemy.data.expr.Parameter" value="{true}">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[695.0, 165.0]">
        </property>
    </entity>
    <entity name="Connected" class="ptolemy.actor.lib.gui.TimedDisplay">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={15, 627, 499, 208}, maximized=false}">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute" value="[499, 164]">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[745.0, 105.0]">
        </property>
    </entity>
    <entity name="Received" class="ptolemy.actor.lib.gui.TimedDisplay">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={0, 692, 499, 208}, maximized=false}">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[575.0, 180.0]">
        </property>
    </entity>
    <entity name="AddSubtract" class="ptolemy.actor.lib.AddSubtract">
        <property name="_location" class="ptolemy.kernel.util.Location" value="[480.0, 230.0]">
        </property>
        <property name="_flipPortsHorizontal" class="ptolemy.data.expr.Parameter" value="true">
        </property>
        <property name="_hideName" class="ptolemy.data.expr.SingletonParameter" value="true">
        </property>
    </entity>
    <entity name="Ramp" class="ptolemy.actor.lib.Ramp">
        <doc>Create a sequence of tokens with increasing value</doc>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[580.0, 255.0]">
        </property>
        <property name="_flipPortsHorizontal" class="ptolemy.data.expr.Parameter" value="true">
        </property>
        <property name="_hideName" class="ptolemy.data.expr.SingletonParameter" value="true">
        </property>
    </entity>
    <entity name="IoTAuthService" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="/*&#10; * Copyright (c) 2016, Regents of the University of California&#10; * All rights reserved.&#10; *&#10; * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:&#10; *&#10; * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.&#10; *&#10; * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.&#10; *&#10; * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&#10; *&#10; * IOTAUTH_COPYRIGHT_VERSION_1&#10; */&#10;&#10;/** This accessor is authenticated/authorized by a local authorization entity, for the&#10; *  Internet of Things (IoT), called 'Auth'. &#10; *&#10; *  This accessor requires the 'socket', 'buffer' and 'crypto' module.&#10; *&#10; *  @accessor net/IoTAuthService&#10; *&#10; *  @input {string} host The IP address or domain name of server. Defaults to 'localhost'.&#10; *  @input {int} port The port on the server to connect to. Defaults to -1, which means&#10; *   wait for a non-negative input before connecting.&#10; *  @input toSend The data to be sent over the secure connection.&#10; *  @output {boolean} connected Output `true` on connected and `false` on disconnected.&#10; *  @output received The data received over the secure connection.&#10; *&#10; *  @parameter {string} authHost The IP address or domain name of an Auth. Defaults to 'localhost'.&#10; *  @parameter {int} authPort The port on the Auth to connect to.&#10; *  @parameter {string} authCertPath The name of the file that stores Auth's certificate that&#10; *    this client will use for communication with the Auth.&#10; *   &#10; *  @parameter {string} entityName The entity's unique name.&#10; *  @parameter {string} entityPrivateKeyPath The name of the file that stores entity's private key,&#10; *    that will be used for communication with the Auth.&#10; *   &#10; *  @parameter {string} publicCipherAlgorithm FIXME: should be given by authCert&#10; *  @parameter {string} signAlgorithm FIXME: should be given by authCert&#10; *&#10; *  @parameter {string} distCipherAlgorithm The symmetric cipher algorithm to be used for distribution of&#10; *    session keys.&#10; *  @parameter {string} distHashAlgorithm The secure hash algorithm to be used for distribution of&#10; *    session keys.&#10; *&#10; *  @author Hokeun Kim&#10; */&#10;&#10;&quot;use strict&quot;;&#10;&#10;var socket = require('socket');&#10;var buffer = require('buffer');&#10;var crypto = require('crypto');&#10;&#10;exports.setup = function() {&#10;	this.input('purpose');&#10;	this.output('sessionKey', {&#10;		type : 'string'&#10;	});&#10;	&#10;	this.parameter('authHost', {&#10;        type : 'string',&#10;        value : 'localhost'&#10;    });&#10;    this.parameter('authPort', {&#10;        value: -1,&#10;        type: 'int'&#10;    });&#10;    this.parameter('authCertPath', {&#10;        value: '',&#10;        type: 'string'&#10;    });&#10;    &#10;    this.parameter('entityName', {&#10;        value: '',&#10;        type: 'string'&#10;    });&#10;    this.parameter('entityPrivateKeyPath', {&#10;        value: '',&#10;        type: 'string'&#10;    });&#10;    &#10;    this.parameter('publicCipherAlgorithm', {&#10;        value: '',&#10;        type: 'string'&#10;    });&#10;    this.parameter('signAlgorithm', {&#10;        value: '',&#10;        type: 'string'&#10;    });&#10;    this.parameter('distCipherAlgorithm', {&#10;        value: '',&#10;        type: 'string'&#10;    });&#10;    this.parameter('distHashAlgorithm', {&#10;        value: '',&#10;        type: 'string'&#10;    });&#10;};&#10;&#10;//////////////// beginning of common code&#10;var msgType = {&#10;    AUTH_HELLO: 0,&#10;    AUTH_SESSION_KEY_REQ: 10,&#10;    AUTH_SESSION_KEY_RESP: 11,&#10;    SESSION_KEY_REQ_IN_PUB_ENC: 20,&#10;    SESSION_KEY_RESP_WITH_DIST_KEY: 21,    // Includes distribution message (session keys)&#10;    SESSION_KEY_REQ: 22,         // Distribution message&#10;    SESSION_KEY_RESP: 23         // Distribution message&#10;};&#10;&#10;var AUTH_NONCE_SIZE = 8;&#10;var S_KEY_ID_SIZE = 8;&#10;var ABS_VALIDITY_SIZE = 6;&#10;var REL_VALIDITY_SIZE = 6;&#10;var DIST_CIPHER_KEY_SIZE = 16;               // 256 bit key = 32 bytes&#10;var SESSION_CIPHER_KEY_SIZE = 16;            // 128 bit key = 16 bytes&#10;&#10;// verialbe length integer encoding&#10;function numToVarLenInt(num) {&#10;    var buf = new buffer.Buffer(0);&#10;    while (num &gt; 127) {&#10;        var extraBuf = new buffer.Buffer(1);&#10;        extraBuf.writeUInt8(128 | num &amp; 127);&#10;        buf = buffer.concat([buf, extraBuf]);&#10;        num &gt;&gt;= 7;&#10;    }&#10;    var extraBuf = new buffer.Buffer(1);&#10;    extraBuf.writeUInt8(num);&#10;    buf = buffer.concat([buf, extraBuf]);&#10;    return buf;&#10;};&#10;&#10;function varLenIntToNum(buf, offset) {&#10;    var num = 0;&#10;    for (var i = 0; i &lt; buf.length &amp;&amp; i &lt; 5; i++) {&#10;        num |= (buf.get(offset + i) &amp; 127) &lt;&lt; (7 * i);&#10;        if ((buf.get(offset + i) &amp; 128) == 0) {&#10;            return {num: num, bufLen: i + 1};&#10;            break;&#10;        }&#10;    }&#10;    return null;&#10;};&#10;&#10;var serializeIoTSP = function(obj) {&#10;    if (obj.msgType == undefined || obj.payload == undefined) {&#10;        console.log('Error: IoTSP msgType or payload is missing.');&#10;        return;&#10;    }&#10;    var msgTypeBuf = new buffer.Buffer(1);&#10;    msgTypeBuf.writeUInt8(obj.msgType, 0);&#10;    var payLoadLenBuf = numToVarLenInt(obj.payload.length);&#10;    return buffer.concat([msgTypeBuf, payLoadLenBuf, obj.payload]);&#10;};&#10;&#10;var parseIoTSP = function(buf) {&#10;    var msgTypeVal = buf.readUInt8(0);&#10;    var ret = varLenIntToNum(buf, 1);&#10;    var payloadVal = buf.slice(1 + ret.bufLen);&#10;    return {msgType: msgTypeVal, payloadLen: ret.num, payload: payloadVal};&#10;};&#10;&#10;var parseAuthHello = function(buf) {&#10;    var authId = buf.readUInt32BE(0);&#10;    var nonce = buf.slice(4, 4 + AUTH_NONCE_SIZE);&#10;    return {authId: authId, nonce: nonce};&#10;};&#10;&#10;var serializeSessionKeyReq = function(obj) {&#10;    if (obj.nonce == undefined || obj.replyNonce == undefined || obj.sender == undefined&#10;        || obj.purpose == undefined || obj.numKeys == undefined) {&#10;        console.log('Error: SessionKeyReq nonce or replyNonce '&#10;            + 'or purpose or numKeys is missing.');&#10;        return;&#10;    }&#10;    var buf = new buffer.Buffer(AUTH_NONCE_SIZE * 2 + 5);&#10;    obj.nonce.copy(buf, 0);&#10;    obj.replyNonce.copy(buf, AUTH_NONCE_SIZE);&#10;    buf.writeUInt32BE(obj.numKeys, AUTH_NONCE_SIZE * 2);&#10;    buf.writeUInt8(obj.sender.length, AUTH_NONCE_SIZE * 2 + 4);&#10;&#10;    var senderBuf = new buffer.Buffer(obj.sender);&#10;    var purposeBuf = new buffer.Buffer(JSON.stringify(obj.purpose));&#10;    return buffer.concat([buf, senderBuf, purposeBuf]);&#10;};&#10;&#10;var serializeSessionKeyReqWithDistributionKey = function(senderName,&#10;    sessionKeyReq, distributionKeyVal, cipherAlgorithm, hashAlgorithm) {&#10;    var sessionKeyReqBuf = serializeSessionKeyReq(sessionKeyReq);&#10;    var encBuf = new buffer.Buffer(crypto.symmetricEncryptWithHash(sessionKeyReqBuf.getArray(),&#10;    	distributionKeyVal, cipherAlgorithm, hashAlgorithm));&#10;&#10;    var senderBuf = new buffer.Buffer(senderName);&#10;    var lengthBuf = new buffer.Buffer(1);&#10;    lengthBuf.writeUInt8(senderBuf.length);&#10;    return buffer.concat([lengthBuf, senderBuf, encBuf]);&#10;};&#10;&#10;var parseDistributionKey = function(buf) {&#10;    var absValidity = new Date(buf.readUIntBE(0, ABS_VALIDITY_SIZE));&#10;    var keyVal = buf.slice(ABS_VALIDITY_SIZE, ABS_VALIDITY_SIZE + DIST_CIPHER_KEY_SIZE);&#10;    return {val: keyVal, absValidity: absValidity};&#10;};&#10;&#10;var parseSessionKey = function(buf) {&#10;    var keyId = buf.readUIntBE(0, S_KEY_ID_SIZE);&#10;    var absValidityValue = buf.readUIntBE(S_KEY_ID_SIZE, ABS_VALIDITY_SIZE);&#10;    var absValidity = new Date(buf.readUIntBE(S_KEY_ID_SIZE, ABS_VALIDITY_SIZE));&#10;    var relValidity = buf.readUIntBE(S_KEY_ID_SIZE + ABS_VALIDITY_SIZE, REL_VALIDITY_SIZE);&#10;    var curIndex =  S_KEY_ID_SIZE + ABS_VALIDITY_SIZE + REL_VALIDITY_SIZE;&#10;    var keyVal = buf.slice(curIndex, curIndex + SESSION_CIPHER_KEY_SIZE);&#10;    return {id: keyId, val: keyVal, absValidity: absValidity, relValidity: relValidity};&#10;};&#10;&#10;var SESSION_KEY_BUF_SIZE = S_KEY_ID_SIZE + ABS_VALIDITY_SIZE + REL_VALIDITY_SIZE + SESSION_CIPHER_KEY_SIZE;&#10;var parseSessionKeyResp = function(buf) {&#10;    var replyNonce = buf.slice(0, AUTH_NONCE_SIZE);&#10;    var bufIdx = AUTH_NONCE_SIZE;&#10;    &#10;	var cryptoSpecLen = buf.readUInt8(bufIdx);&#10;	bufIdx += 1;&#10;	var cryptoSpecStr = buf.toString(bufIdx, bufIdx + cryptoSpecLen);&#10;	bufIdx += cryptoSpecLen;&#10;	&#10;    var sessionKeyCount = buf.readUInt32BE(bufIdx);&#10;&#10;    bufIdx += 4;&#10;    var sessionKeyList = [];&#10;    for (var i = 0; i &lt; sessionKeyCount; i++) {&#10;        var sessionKey = parseSessionKey(buf.slice(bufIdx));&#10;        sessionKeyList.push(sessionKey);&#10;        bufIdx += SESSION_KEY_BUF_SIZE;&#10;    }&#10;    return {replyNonce: replyNonce, sessionKeyList: sessionKeyList};&#10;};&#10;//////////////// end of common code&#10;&#10;// auth and entity info&#10;var authPublicKey;&#10;var entityPrivateKey;&#10;var entityName;&#10;&#10;// crypto info&#10;var publicCipherAlgorithm;&#10;var signAlgorithm;&#10;var distCipherAlgorithm;&#10;var distHashAlgorithm;&#10;&#10;// local variables&#10;var self;&#10;var client = null;&#10;var distributionKey = null;&#10;var sessionKeyList = [];&#10;&#10;function outputSessionKey(sessionKey) {&#10;	sessionKey.val = sessionKey.val.getArray();&#10;    self.send('sessionKey', JSON.stringify(sessionKey));&#10;};&#10;&#10;function handleSessionKeyResp(obj, myNonce) {&#10;	if (obj.msgType == msgType.SESSION_KEY_RESP_WITH_DIST_KEY) {&#10;        console.log('received session key response with distribution key attached!');&#10;        var distKeyBuf = obj.payload.slice(0, 512);&#10;        var sessionKeyRespBuf = obj.payload.slice(512);&#10;        var pubEncData = distKeyBuf.slice(0, 256).getArray();&#10;        var signature = distKeyBuf.slice(256).getArray();&#10;        var verified = crypto.verifySignature(pubEncData, signature, authPublicKey, signAlgorithm);&#10;        if (!verified) {&#10;        	console.log('Auth signature NOT verified');&#10;        	return;&#10;        }&#10;    	console.log('Auth signature verified');&#10;    	distKeyBuf = new buffer.Buffer(&#10;    		crypto.privateDecrypt(pubEncData, entityPrivateKey, publicCipherAlgorithm));&#10;    	var receivedDistKey = parseDistributionKey(distKeyBuf);&#10;    	&#10;        var ret = crypto.symmetricDecryptWithHash(sessionKeyRespBuf.getArray(),&#10;        	receivedDistKey.val.getArray(), distCipherAlgorithm, distHashAlgorithm);&#10;        if (!ret.hashOk) {&#10;        	console.log('Received hash for session key resp is NOT ok');&#10;        	return;&#10;        }&#10;    	console.log('Received hash for session key resp is ok');&#10;    	sessionKeyRespBuf = new buffer.Buffer(ret.data);&#10;    	var sessionKeyResp = parseSessionKeyResp(sessionKeyRespBuf);&#10;    	if (!sessionKeyResp.replyNonce.equals(myNonce)) {&#10;        	console.log('Auth nonce NOT verified');&#10;        	return;&#10;    	}&#10;    	console.log('Auth nonce verified');&#10;    	&#10;    	console.log('Updating to a new distribution key key');&#10;    	distributionKey = receivedDistKey;&#10;    	console.log(distributionKey);&#10;    	&#10;    	console.log('received ' + sessionKeyResp.sessionKeyList.length + ' session keys');&#10;    	for (var i = 0; i &lt; sessionKeyResp.sessionKeyList.length; i++) {&#10;    		sessionKeyList.push(sessionKeyResp.sessionKeyList[i]);&#10;    	}&#10;    	console.log('Status: Connection closed after receiving auth response.');&#10;	}&#10;	else if (obj.msgType == msgType.SESSION_KEY_RESP) {&#10;		console.log('received session key response encrypted with distribution key');&#10;		var ret = crypto.symmetricDecryptWithHash(obj.payload.getArray(),&#10;        	distributionKey.val.getArray(), distCipherAlgorithm, distHashAlgorithm);&#10;        if (!ret.hashOk) {&#10;        	console.log('Received hash for session key resp is NOT ok');&#10;        	return;&#10;        }&#10;    	console.log('Received hash for session key resp is ok');&#10;        var decBuf = new buffer.Buffer(ret.data);&#10;        var sessionKeyResp = parseSessionKeyResp(decBuf);&#10;    	if (!sessionKeyResp.replyNonce.equals(myNonce)) {&#10;        	console.log('Auth nonce NOT verified');&#10;        	return;&#10;    	}&#10;    	console.log('Auth nonce verified');&#10;    	&#10;    	for (var i = 0; i &lt; sessionKeyResp.sessionKeyList.length; i++) {&#10;    		sessionKeyList.push(sessionKeyResp.sessionKeyList[i]);&#10;    	}&#10;    	console.log('Status: Connection closed after receiving auth response.');&#10;	}&#10;	if (sessionKeyList.length &gt; 0) {&#10;		outputSessionKey(sessionKeyList.shift());&#10;	}&#10;};&#10;&#10;function sendSessionKeyReq(authHost, authPort, numKeys, purpose) {&#10;	if (client) {&#10;		// Either the host or the port has changed. Close the previous socket.&#10;		client.close();&#10;	}&#10;    client = new socket.SocketClient(authPort, authHost,&#10;    {&#10;        //'connectTimeout' : this.getParameter('connectTimeout'),&#10;        'discardMessagesBeforeOpen' : false,&#10;        'emitBatchDataAsAvailable' : true,&#10;        //'idleTimeout' : this.getParameter('idleTimeout'),&#10;        'keepAlive' : false,&#10;        //'maxUnsentMessages' : this.getParameter('maxUnsentMessages'),&#10;        //'noDelay' : this.getParameter('noDelay'),&#10;        //'pfxKeyCertPassword' : this.getParameter('pfxKeyCertPassword'),&#10;        //'pfxKeyCertPath' : this.getParameter('pfxKeyCertPath'),&#10;        'rawBytes' : true,&#10;        //'receiveBufferSize' : this.getParameter('receiveBufferSize'),&#10;        'receiveType' : 'byte',&#10;        //'reconnectAttempts' : this.getParameter('reconnectAttempts'),&#10;        //'reconnectInterval' : this.getParameter('reconnectInterval'),&#10;        //'sendBufferSize' : this.getParameter('sendBufferSize'),&#10;        'sendType' : 'byte',&#10;        //'sslTls' : this.getParameter('sslTls'),&#10;        //'trustAll' : this.getParameter('trustAll'),&#10;        //'trustedCACertPath' : this.getParameter('trustedCACertPath')&#10;    });&#10;    client.on('open', function() {&#10;    	console.log('connected to auth');&#10;    });&#10;    var myNonce;&#10;    client.on('data', function(data) {&#10;    	console.log('data received from auth');&#10;		var buf = new buffer.Buffer(data);&#10;		var obj = parseIoTSP(buf);&#10;		if (obj.msgType == msgType.AUTH_HELLO) {&#10;			var authHello = parseAuthHello(obj.payload);&#10;			myNonce = new buffer.Buffer(crypto.randomBytes(AUTH_NONCE_SIZE));&#10;		&#10;            var sessionKeyReq = {&#10;                nonce: myNonce,&#10;                replyNonce: authHello.nonce,&#10;                numKeys: numKeys,&#10;                sender: entityName,&#10;                purpose: purpose&#10;            };&#10;			var msg;&#10;            if (distributionKey == null || distributionKey.absValidity &lt; new Date()) {&#10;                if (distributionKey != null) {&#10;                    console.log('current distribution key expired, '&#10;                        + 'requesting new distribution key as well...');&#10;                }&#10;                else {&#10;                    console.log('no distribution key available yet, '&#10;                        + 'requesting new distribution key as well...');&#10;                }&#10;	            var sessionKeyReqBuf = serializeSessionKeyReq(sessionKeyReq);&#10;	            var payload = new buffer.Buffer(&#10;	            	crypto.publicEncryptAndSign(sessionKeyReqBuf.getArray(),&#10;	            	authPublicKey, entityPrivateKey,&#10;	            	publicCipherAlgorithm, signAlgorithm));&#10;	            msg = {&#10;	            	msgType: msgType.SESSION_KEY_REQ_IN_PUB_ENC,&#10;	            	payload: payload&#10;	            };&#10;            }&#10;            else {&#10;                console.log('distribution key available! ');&#10;                msg = {&#10;                	msgType: msgType.SESSION_KEY_REQ,&#10;                	payload: serializeSessionKeyReqWithDistributionKey(entityName,&#10;                		sessionKeyReq, distributionKey.val.getArray(), distCipherAlgorithm, distHashAlgorithm)&#10;                };&#10;            }&#10;            var toSend = serializeIoTSP(msg).getArray();&#10;            client.send(toSend);&#10;		}&#10;		else if (obj.msgType == msgType.SESSION_KEY_RESP_WITH_DIST_KEY ||&#10;		    obj.msgType == msgType.SESSION_KEY_RESP) {&#10;	    	handleSessionKeyResp(obj, myNonce);&#10;	    	client.close();&#10;		}&#10;    });&#10;    client.on('close', function() {&#10;    	console.log('disconnected from auth');&#10;    });&#10;    client.on('error', function(message) {&#10;    	console.log('an error occurred');&#10;        self.error(message);&#10;    });&#10;	client.open();&#10;};&#10;&#10;exports.purposeInputHandler = function() {&#10;	if (sessionKeyList.length &gt; 0) {&#10;		outputSessionKey(sessionKeyList.shift());&#10;	}&#10;	else {&#10;		// JSON.parse(this.get('purpose'))&#10;		// {group: 'Servers'}&#10;		sendSessionKeyReq(this.getParameter('authHost'), this.getParameter('authPort'),&#10;			2, this.get('purpose'));&#10;	}&#10;};&#10;&#10;exports.initialize = function () {&#10;	authPublicKey = crypto.loadPublicKey(this.getParameter('authCertPath'));&#10;	entityPrivateKey = crypto.loadPrivateKey(this.getParameter('entityPrivateKeyPath'));&#10;	&#10;	entityName = this.getParameter('entityName');&#10;	publicCipherAlgorithm = this.getParameter('publicCipherAlgorithm');&#10;	signAlgorithm = this.getParameter('signAlgorithm');&#10;	distCipherAlgorithm = this.getParameter('distCipherAlgorithm');&#10;	distHashAlgorithm = this.getParameter('distHashAlgorithm');&#10;	&#10;	self = this;&#10;	&#10;	this.addInputHandler('purpose',&#10;		this.exports.purposeInputHandler.bind(this));&#10;};&#10;&#10;/** Close the web socket connection. */&#10;exports.wrapup = function () {&#10;    if (client) {&#10;        client.close();&#10;        console.log('Status: Connection closed in wrapup.');&#10;    }&#10;};&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="$PROJECT_PATH/accessors/IoTAuthService.js">
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[355.0, 105.0]">
        </property>
        <property name="authHost" class="ptolemy.data.expr.Parameter" value="localhost">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="authPort" class="ptolemy.data.expr.Parameter" value="21900">
        </property>
        <property name="authCertPath" class="ptolemy.data.expr.Parameter" value="$PROJECT_PATH/entity/auth_certs/Auth101EntityCert.pem">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="entityName" class="ptolemy.data.expr.Parameter" value="net1.ptClient">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="entityPrivateKeyPath" class="ptolemy.data.expr.Parameter" value="$PROJECT_PATH/entity/credentials/keys/net1/PtClientKey.der">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="publicCipherAlgorithm" class="ptolemy.data.expr.Parameter" value="RSA/ECB/PKCS1PADDING">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="signAlgorithm" class="ptolemy.data.expr.Parameter" value="SHA256withRSA">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="distCipherAlgorithm" class="ptolemy.data.expr.Parameter" value="AES-128-CBC">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="distHashAlgorithm" class="ptolemy.data.expr.Parameter" value="SHA-256">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <port name="purpose" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="sessionKey" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
    </entity>
    <entity name="IoTAuthorizedClient" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="/*&#10; * Copyright (c) 2016, Regents of the University of California&#10; * All rights reserved.&#10; *&#10; * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:&#10; *&#10; * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.&#10; *&#10; * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.&#10; *&#10; * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&#10; *&#10; * IOTAUTH_COPYRIGHT_VERSION_1&#10; */&#10;&#10;/** This accessor sets up a secure, authenticated and authorized connection with a server.&#10; *  It does this by getting authenticated and authorized by a local authentication and authorization&#10; *  entity called 'Auth'.&#10; *  'Secure' means that the communications are encrypted; 'authenticated' means that the identity of both&#10; *  this client and the server are guaranteed by Auth; and 'authorized' means that the client and server&#10; *  are registered with Auth as eligible to communicate with one another.&#10; *  &#10; *  Once a secure connection is established with the server, this accessor can send and/or&#10; *  receive messages protected by a session key given by Auth. A session key is a &#10; *  symmetric key with a validity period. 'Symmetric' means that this client and the server use the same key.&#10; *  'Protected' means encrypted and/or authenticated.&#10; *&#10; *  This accessor will attempt to establish a secure connection with the server specified by parameters (host, port)&#10; *  when it first receives an input on its input port(FIXME).&#10; *  To do this it needs to communicate with Auth which is specified by the paramaters (FIXME)&#10; *  &#10; *  FIXME: explain what happens if this connection fails, connectionError port&#10; *  (use throw exception rather than console output)&#10; *&#10; *  In order to be authorized by an Auth, there must be an Auth that is running and reachable by this accessor.&#10; *  &#10; *  // 2) The HW/SW network entity on which this accessor is running&#10; *  // should be registered with the Auth. The network entity can be a single device, a virtual&#10; *  // machine, a software application, etc. -&gt; with the registration instructions&#10; *&#10; *  An open-source implementation of Auth is available on public repository (FIXME: &#10; *  insert a link to a repository after setting up the repository).&#10; *&#10; *  To register this client on which the swarmlet is running, &#10; *  1) The client must have a public/private key pair, and a unique name (string).&#10; *  2) The client's public key and unique name should be stored in Auth's database.&#10; *  3) The key distribution conditions of the session keys must be set up with the Auth.&#10; *  These conditions include the cipher and hash algorithms for key distribution, and the&#10; *  validity periods of the distribution keys. A distribution key is a symmetric key-wrapping&#10; *  key for session keys.&#10; *  4) The path of the Auth's certificate (which includes Auth's public key) must be&#10; *  available to this accessor.&#10; *  Detailed information of the entity registration can be found in the tutorial available&#10; *  on (FIXME: put a link to the tutorial here.)&#10; *  &#10; *  When the secure connection is established, a `true` boolean is sent to&#10; *  the `connected` output. If the secure connection is broken during execution, then a `false`&#10; *  boolean is sent to the `connected` output. The swarmlet could respond to this by&#10; *  retrying to connect (send an event to either the `port` or `host` input).&#10; *  &#10; *  Whenever an input is received on the `toSend` input, the data on that input is sent &#10; *  over the secure connection. If the secure connection is not yet established,&#10; *  input messages that are received before the establishment of the secure connection&#10; *  will be discarded.&#10; *&#10; *  Whenever a message is received from over secure connection, that message is&#10; *  produced on the `received` output.&#10; *&#10; *  When `wrapup()` is invoked, this accessor closes the secure connection.&#10; *&#10; *  This accessor requires the 'socket', 'buffer' and 'crypto' module.&#10; *&#10; *  @accessor net/IoTAuthorizedClient&#10; *&#10; *  @input {string} host The IP address or domain name of server. Defaults to 'localhost'.&#10; *  @input {int} port The port on the server to connect to. Defaults to -1, which means&#10; *   wait for a non-negative input before connecting.&#10; *  @input toSend The data to be sent over the socket.&#10; *&#10; *  @output {boolean} connected Output `true` on connected and `false` on disconnected.&#10; *  @output received The data received from the web socket server.&#10; *&#10; *&#10; *  @parameter {string} authHost The IP address or domain name of an Auth. Defaults to 'localhost'.&#10; *  @parameter {int} authPort The port on the Auth to connect to.&#10; *  @parameter {string} authCertPath The name of the file that stores Auth's certificate that&#10; *    this client will use for communication with the Auth.&#10; *   &#10; *  @parameter {string} entityName The entity's unique name.&#10; *  @parameter {string} entityPrivateKeyPath The name of the file that stores entity's private key,&#10; *    that will be used for communication with the Auth.&#10; *   &#10; *  @parameter {string} publicCipherAlgorithm FIXME: should be included in Auth's certificate&#10; *  @parameter {string} signAlgorithm FIXME: should be included in Auth's certificate&#10; *&#10; *  @parameter {string} distCipherAlgorithm The symmetric cipher algorithm to be used for distribution of&#10; *    session keys.&#10; *  @parameter {string} distHashAlgorithm The secure hash algorithm to be used for distribution of&#10; *    session keys.&#10; *&#10; *  @parameter {string} serverHost The IP address or domain name of a server. Defaults to 'localhost'.&#10; *  @parameter {int} serverPort The port on the server to connect to.&#10; *  @parameter {string} sessionCipherAlgorithm The symmetric cipher algorithm to be used for the&#10; *    secure connection with the server.&#10; *  @parameter {string} sessionHashAlgorithm The secure hash algorithm to be used for the&#10; *    secure connection with the server.&#10; *&#10; *  @author Hokeun Kim&#10; */&#10;&#10;&#10;&quot;use strict&quot;;&#10;&#10;var socket = require('socket');&#10;var buffer = require('buffer');&#10;var crypto = require('crypto');&#10;&#10;exports.setup = function() {&#10;	this.input('sessionKey', {&#10;		type : 'string'&#10;	});&#10;	this.input('toSend', {&#10;		type : 'string'&#10;	});&#10;	this.output('connected', {&#10;		type: 'boolean'&#10;	});&#10;	this.output('received', {&#10;		type : 'string'&#10;	});&#10;	&#10;	this.parameter('serverHost', {&#10;        type : 'string',&#10;        value : 'localhost'&#10;    });&#10;    this.parameter('serverPort', {&#10;        value: -1,&#10;        type: 'int'&#10;    });&#10;    &#10;    this.parameter('sessionCipherAlgorithm', {&#10;        value: '',&#10;        type: 'string'&#10;    });&#10;    this.parameter('sessionHashAlgorithm', {&#10;        value: '',&#10;        type: 'string'&#10;    });&#10;};&#10;&#10;//////////////// beginning of common code&#10;var msgType = {&#10;    SKEY_HANDSHAKE_1: 30,&#10;    SKEY_HANDSHAKE_2: 31,&#10;    SKEY_HANDSHAKE_3: 32,&#10;    SECURE_COMM_MSG: 33,&#10;    FIN_SECURE_COMM: 34,&#10;    SECURE_PUB: 40&#10;};&#10;var HS_NONCE_SIZE = 8;            // handshake nonce size&#10;var S_KEY_ID_SIZE = 8;&#10;var SEQ_NUM_SIZE = 8;&#10;&#10;// verialbe length integer encoding&#10;function numToVarLenInt(num) {&#10;    var buf = new buffer.Buffer(0);&#10;    while (num &gt; 127) {&#10;        var extraBuf = new buffer.Buffer(1);&#10;        extraBuf.writeUInt8(128 | num &amp; 127);&#10;        buf = buffer.concat([buf, extraBuf]);&#10;        num &gt;&gt;= 7;&#10;    }&#10;    var extraBuf = new buffer.Buffer(1);&#10;    extraBuf.writeUInt8(num);&#10;    buf = buffer.concat([buf, extraBuf]);&#10;    return buf;&#10;};&#10;&#10;function varLenIntToNum(buf, offset) {&#10;    var num = 0;&#10;    for (var i = 0; i &lt; buf.length &amp;&amp; i &lt; 5; i++) {&#10;        num |= (buf.get(offset + i) &amp; 127) &lt;&lt; (7 * i);&#10;        if ((buf.get(offset + i) &amp; 128) == 0) {&#10;            return {num: num, bufLen: i + 1};&#10;            break;&#10;        }&#10;    }&#10;    return null;&#10;};&#10;&#10;/*&#10;    IoTSP (IoT Secure Protocol) Message&#10;    {&#10;        msgType: /UInt8/,&#10;        payloadLen: /variable-length integer encoding/&#10;        payload: /Buffer/&#10;    }&#10;*/&#10;var serializeIoTSP = function(obj) {&#10;    if (obj.msgType == undefined || obj.payload == undefined) {&#10;        console.log('Error: IoTSP msgType or payload is missing.');&#10;        return;&#10;    }&#10;    var msgTypeBuf = new buffer.Buffer(1);&#10;    msgTypeBuf.writeUInt8(obj.msgType, 0);&#10;    var payLoadLenBuf = numToVarLenInt(obj.payload.length);&#10;    return buffer.concat([msgTypeBuf, payLoadLenBuf, obj.payload]);&#10;};&#10;&#10;var parseIoTSP = function(buf) {&#10;    var msgTypeVal = buf.readUInt8(0);&#10;    var ret = varLenIntToNum(buf, 1);&#10;    var payloadVal = buf.slice(1 + ret.bufLen);&#10;    return {msgType: msgTypeVal, payloadLen: ret.num, payload: payloadVal};&#10;};&#10;&#10;/*&#10;    Handshake Format&#10;    {&#10;        nonce: /Buffer/, // encrypted, may be undefined&#10;        replyNonce: /Buffer/, // encrypted, may be undefined&#10;    }&#10;*/&#10;var serializeHandshake = function(obj) {&#10;    if (obj.nonce == undefined &amp;&amp; obj.replyNonce == undefined) {&#10;        console.log('Error: handshake should include at least on nonce.');&#10;        return;&#10;    }&#10;    var buf = new buffer.Buffer(1 + HS_NONCE_SIZE * 2);&#10;&#10;    // indicates existance of nonces&#10;    var indicator = 0;&#10;    if (obj.nonce != undefined) {&#10;        indicator += 1;&#10;        obj.nonce.copy(buf, 1);&#10;    }&#10;    if (obj.replyNonce != undefined) {&#10;        indicator += 2;&#10;        obj.replyNonce.copy(buf, 1 + HS_NONCE_SIZE);&#10;    }&#10;    buf.writeUInt8(indicator, 0);&#10;&#10;    return buf;&#10;};&#10;&#10;// buf should be just the unencrypted part&#10;var parseHandshake = function(buf) {&#10;    var obj = {};&#10;    var indicator = buf.readUInt8(0);&#10;    if ((indicator &amp; 1) != 0) {&#10;        // nonce exists&#10;        obj.nonce = buf.slice(1, 1 + HS_NONCE_SIZE);&#10;    }&#10;    if ((indicator &amp; 2) != 0) {&#10;        // replayNonce exists&#10;        obj.replyNonce = buf.slice(1 + HS_NONCE_SIZE, 1 + HS_NONCE_SIZE * 2);&#10;    }&#10;    return obj;&#10;};&#10;&#10;/*&#10;    SecureSessionMessage Format&#10;    {&#10;        SeqNum: /Buffer/, // UIntBE, SEQ_NUM_SIZE Bytes&#10;        data: /Buffer/,&#10;    }&#10;*/&#10;var serializeSessionMessage = function(obj) {&#10;    if (obj.seqNum == undefined || obj.data == undefined) {&#10;        console.log('Error: Secure session message seqNum or data is missing.');&#10;        return;&#10;    }&#10;    var seqNumBuf = new buffer.Buffer(SEQ_NUM_SIZE);&#10;    seqNumBuf.writeUIntBE(obj.seqNum, 0, SEQ_NUM_SIZE);&#10;    return buffer.concat([seqNumBuf, obj.data]);&#10;};&#10;var parseSessionMessage = function(buf) {&#10;    var seqNum = buf.readUIntBE(0, SEQ_NUM_SIZE);&#10;    var data = buf.slice(SEQ_NUM_SIZE);&#10;    return {seqNum: seqNum, data: data};&#10;};&#10;//////////////// end of common code&#10;&#10;// crypto info&#10;var sessionCipherAlgorithm;&#10;var sessionHashAlgorithm;&#10;&#10;// client communication state&#10;var clientCommState = {&#10;    IDLE: 0,&#10;    HANDSHAKE_1_SENT: 10,&#10;    IN_COMM: 30                    // Session message&#10;};&#10;&#10;// local variables&#10;var self;&#10;var client = null;&#10;var sessionKey = null;&#10;var currentState = clientCommState.IDLE;&#10;var writeSeqNum = 0;&#10;var readSeqNum = 0;&#10;&#10;function initComm(serverHost, serverPort) {&#10;	if (client) {&#10;		// Either the host or the port has changed. Close the previous socket.&#10;		client.close();&#10;	}&#10;    client = new socket.SocketClient(serverPort, serverHost,&#10;    {&#10;        //'connectTimeout' : this.getParameter('connectTimeout'),&#10;        'discardMessagesBeforeOpen' : false,&#10;        'emitBatchDataAsAvailable' : true,&#10;        //'idleTimeout' : this.getParameter('idleTimeout'),&#10;        //'keepAlive' : false,&#10;        //'maxUnsentMessages' : this.getParameter('maxUnsentMessages'),&#10;        //'noDelay' : this.getParameter('noDelay'),&#10;        //'pfxKeyCertPassword' : this.getParameter('pfxKeyCertPassword'),&#10;        //'pfxKeyCertPath' : this.getParameter('pfxKeyCertPath'),&#10;        'rawBytes' : true,&#10;        //'receiveBufferSize' : this.getParameter('receiveBufferSize'),&#10;        'receiveType' : 'byte',&#10;        //'reconnectAttempts' : this.getParameter('reconnectAttempts'),&#10;        //'reconnectInterval' : this.getParameter('reconnectInterval'),&#10;        //'sendBufferSize' : this.getParameter('sendBufferSize'),&#10;        'sendType' : 'byte',&#10;        //'sslTls' : this.getParameter('sslTls'),&#10;        //'trustAll' : this.getParameter('trustAll'),&#10;        //'trustedCACertPath' : this.getParameter('trustedCACertPath')&#10;    });&#10;    &#10;    var myNonce;&#10;    client.on('open', function() {&#10;    	console.log('connected to server');&#10;    	if (sessionKey == null) {&#10;	        console.log('No available key');&#10;	        return;&#10;    	}&#10;    	myNonce = new buffer.Buffer(crypto.randomBytes(HS_NONCE_SIZE));&#10;        console.log('chosen nonce: ' + myNonce.inspect());&#10;        var handshake1 = {nonce: myNonce};&#10;        var buf = serializeHandshake(handshake1);&#10;        var encBuf = new buffer.Buffer(crypto.symmetricEncryptWithHash(buf.getArray(),&#10;    		sessionKey.val, sessionCipherAlgorithm, sessionHashAlgorithm));&#10;    	&#10;        var keyIdBuf = new buffer.Buffer(S_KEY_ID_SIZE);&#10;        keyIdBuf.writeUIntBE(sessionKey.id, 0, S_KEY_ID_SIZE);&#10;        var msg = {&#10;            msgType: msgType.SKEY_HANDSHAKE_1,&#10;            payload: buffer.concat([keyIdBuf, encBuf])&#10;        };&#10;        var toSend = serializeIoTSP(msg).getArray();&#10;        client.send(toSend);&#10;        console.log('switching to HANDSHAKE_1_SENT');&#10;        currentState = clientCommState.HANDSHAKE_1_SENT;&#10;    });&#10;    client.on('data', function(data) {&#10;    	console.log('data received from server');&#10;		var obj = parseIoTSP(new buffer.Buffer(data));&#10;    	if (obj.msgType == msgType.SKEY_HANDSHAKE_2) {&#10;            console.log('received session key handshake2!');&#10;            if (currentState != clientCommState.HANDSHAKE_1_SENT) {&#10;                console.log('Error: wrong sequence of handshake, disconnecting...');&#10;                currentState = clientCommState.IDLE;&#10;                client.close();&#10;                return;&#10;            }&#10;            var ret = crypto.symmetricDecryptWithHash(obj.payload.getArray(),&#10;    			sessionKey.val, sessionCipherAlgorithm, sessionHashAlgorithm);&#10;    		if (!ret.hashOk) {&#10;        		console.log('Received hash for handshake2 is NOT ok');&#10;    			return;&#10;    		}&#10;    		console.log('Received hash for handshake2 is ok');&#10;    		var buf = new buffer.Buffer(ret.data);&#10;    		var handshake2 = parseHandshake(buf);&#10;    		if (!handshake2.replyNonce.equals(myNonce)) {&#10;        		console.log('Server nonce NOT verified');&#10;    			return;&#10;    		}&#10;    		console.log('Server nonce verified');&#10;    		var theirNonce = handshake2.nonce;&#10;    		var handshake3 = {replyNonce: theirNonce};&#10;    		buf = serializeHandshake(handshake3);&#10;    		var encBuf = new buffer.Buffer(crypto.symmetricEncryptWithHash(buf.getArray(),&#10;    			sessionKey.val, sessionCipherAlgorithm, sessionHashAlgorithm));&#10;    		var msg = {&#10;    			msgType: msgType.SKEY_HANDSHAKE_3,&#10;    			payload: encBuf&#10;    		};&#10;    		client.send(serializeIoTSP(msg).getArray());&#10;	        console.log('switching to IN_COMM');&#10;	        currentState = clientCommState.IN_COMM;&#10;	        writeSeqNum = 0;&#10;	        readSeqNum = 0;&#10;	        self.send('connected', true);&#10;    	}&#10;    	else if (obj.msgType == msgType.SECURE_COMM_MSG) {&#10;            console.log('received secure communication message!');&#10;            if (currentState != clientCommState.IN_COMM) {&#10;                console.log('Error: it is not in IN_COMM state, disconecting...');&#10;                currentState = clientCommState.IDLE;&#10;                client.close();&#10;                return;&#10;            }&#10;            var ret = crypto.symmetricDecryptWithHash(obj.payload.getArray(),&#10;    			sessionKey.val, sessionCipherAlgorithm, sessionHashAlgorithm);&#10;    		if (!ret.hashOk) {&#10;        		console.log('Received hash for secure comm msg is NOT ok');&#10;    			return;&#10;    		}&#10;    		console.log('Received hash for secure comm msg is ok');&#10;    		var buf = new buffer.Buffer(ret.data);&#10;    		ret = parseSessionMessage(buf);&#10;    		&#10;            if (ret.seqNum != readSeqNum) {&#10;            	console.log('seqNum does not match! expected: ' + readSeqNum + ' received: ' + ret.seqNum);&#10;            }&#10;            readSeqNum++;&#10;        	console.log('seqNum: ' + ret.seqNum + ' data: ' + ret.data);&#10;        	&#10;	        self.send('received', ret.data.toString());&#10;    	}&#10;    });&#10;    client.on('close', function() {&#10;    	console.log('disconnected from server');&#10;        console.log('switching to IDLE');&#10;        currentState = clientCommState.IDLE;&#10;    });&#10;    client.on('error', function(message) {&#10;    	console.log('an error occurred');&#10;        self.error(message);&#10;    });&#10;	client.open();&#10;}&#10;&#10;exports.sessionKeyInputHandler = function() {&#10;	sessionKey = JSON.parse(this.get('sessionKey'));&#10;	sessionKey.absValidity = new Date(sessionKey.absValidity);&#10;	console.log(sessionKey);&#10;	initComm(this.getParameter('serverHost'), this.getParameter('serverPort'));&#10;};&#10;&#10;exports.toSendInputHandler = function () {&#10;	var toSend = this.get('toSend');&#10;	// May be receiving inputs before client has been set.&#10;	if (client &amp;&amp; currentState == clientCommState.IN_COMM) {&#10;		var buf = serializeSessionMessage({seqNum: writeSeqNum, data: new buffer.Buffer(toSend)});&#10;		var encBuf = new buffer.Buffer(crypto.symmetricEncryptWithHash(buf.getArray(),&#10;			sessionKey.val, sessionCipherAlgorithm, sessionHashAlgorithm));&#10;		writeSeqNum++;&#10;		var msg = {&#10;			msgType: msgType.SECURE_COMM_MSG,&#10;			payload: encBuf&#10;		};&#10;		var toSend = serializeIoTSP(msg).getArray();&#10;		client.send(toSend);&#10;	}&#10;	else {&#10;        console.log('Discarding data because socket is not open.');&#10;	}&#10;};&#10;&#10;exports.initialize = function () {&#10;	currentState = clientCommState.IDLE;&#10;    writeSeqNum = 0;&#10;    readSeqNum = 0;&#10;	sessionKey = null;&#10;	&#10;	sessionCipherAlgorithm = this.getParameter('sessionCipherAlgorithm');&#10;	sessionHashAlgorithm = this.getParameter('sessionHashAlgorithm');&#10;	&#10;	self = this;&#10;	&#10;	this.addInputHandler('sessionKey',&#10;		this.exports.sessionKeyInputHandler.bind(this));&#10;	this.addInputHandler('toSend',&#10;		this.exports.toSendInputHandler.bind(this));&#10;};&#10;&#10;/** Close the web socket connection. */&#10;exports.wrapup = function () {&#10;    if (client) {&#10;        client.close();&#10;        console.log('Status: Connection closed in wrapup.');&#10;        console.log('switching to IDLE state.');&#10;        currentState = clientCommState.IDLE;&#10;    }&#10;};&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="$PROJECT_PATH/accessors/IoTAuthorizedClient.js">
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="{500.0, 115.0}">
        </property>
        <property name="serverHost" class="ptolemy.data.expr.Parameter" value="localhost">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="serverPort" class="ptolemy.data.expr.Parameter" value="21200">
        </property>
        <property name="sessionCipherAlgorithm" class="ptolemy.data.expr.Parameter" value="AES-128-CBC">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="sessionHashAlgorithm" class="ptolemy.data.expr.Parameter" value="SHA-256">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <port name="sessionKey" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="toSend" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="connected" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
        <port name="received" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
    </entity>
    <relation name="relation7" class="ptolemy.actor.TypedIORelation">
        <property name="width" class="ptolemy.data.expr.Parameter" value="-1">
        </property>
        <vertex name="vertex1" value="[635.0, 105.0]">
        </vertex>
    </relation>
    <relation name="relation10" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation11" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation8" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation13" class="ptolemy.actor.TypedIORelation">
        <property name="width" class="ptolemy.data.expr.Parameter" value="-1">
        </property>
        <vertex name="vertex1" value="[750.0, 165.0]">
        </vertex>
    </relation>
    <relation name="relation14" class="ptolemy.actor.TypedIORelation">
        <property name="width" class="ptolemy.data.expr.Parameter" value="-1">
        </property>
        <vertex name="vertex1" value="[750.0, 220.0]">
        </vertex>
    </relation>
    <relation name="relation15" class="ptolemy.actor.TypedIORelation">
        <property name="width" class="ptolemy.data.expr.Parameter" value="-1">
        </property>
        <vertex name="vertex1" value="[750.0, 245.0]">
        </vertex>
    </relation>
    <relation name="relation2" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation3" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation5" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation4" class="ptolemy.actor.TypedIORelation">
    </relation>
    <link port="SingleEvent.output" relation="relation2"/>
    <link port="Const.output" relation="relation"/>
    <link port="Const.trigger" relation="relation2"/>
    <link port="MicrostepDelay.input" relation="relation7"/>
    <link port="MicrostepDelay.output" relation="relation10"/>
    <link port="Const2.output" relation="relation11"/>
    <link port="Const2.trigger" relation="relation14"/>
    <link port="DiscreteClock.output" relation="relation13"/>
    <link port="DiscreteClock.start" relation="relation10"/>
    <link port="Connected.input" relation="relation7"/>
    <link port="Received.input" relation="relation3"/>
    <link port="AddSubtract.plus" relation="relation11"/>
    <link port="AddSubtract.plus" relation="relation8"/>
    <link port="AddSubtract.output" relation="relation5"/>
    <link port="Ramp.output" relation="relation8"/>
    <link port="Ramp.trigger" relation="relation15"/>
    <link port="IoTAuthService.purpose" relation="relation"/>
    <link port="IoTAuthService.sessionKey" relation="relation4"/>
    <link port="IoTAuthorizedClient.sessionKey" relation="relation4"/>
    <link port="IoTAuthorizedClient.toSend" relation="relation5"/>
    <link port="IoTAuthorizedClient.connected" relation="relation7"/>
    <link port="IoTAuthorizedClient.received" relation="relation3"/>
    <link relation1="relation13" relation2="relation14"/>
    <link relation1="relation14" relation2="relation15"/>
</entity>
