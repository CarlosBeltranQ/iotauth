<?xml version="1.0" standalone="no"?>
<!DOCTYPE entity PUBLIC "-//UC Berkeley//DTD MoML 1//EN"
    "http://ptolemy.eecs.berkeley.edu/xml/dtd/MoML_1.dtd">
<entity name="ptServer" class="ptolemy.actor.TypedCompositeActor">
    <property name="_createdBy" class="ptolemy.kernel.attributes.VersionAttribute" value="11.0.devel">
    </property>
    <property name="DE Director" class="ptolemy.domains.de.kernel.DEDirector">
        <property name="startTime" class="ptolemy.data.expr.Parameter" value="0">
        </property>
        <property name="stopTime" class="ptolemy.data.expr.Parameter" value="10">
        </property>
        <property name="stopWhenQueueIsEmpty" class="ptolemy.data.expr.Parameter" value="false">
        </property>
        <property name="synchronizeToRealTime" class="ptolemy.data.expr.Parameter" value="true">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[350.0, 135.0]">
        </property>
    </property>
    <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={606, 557, 730, 509}, maximized=false}">
    </property>
    <property name="_vergilSize" class="ptolemy.actor.gui.SizeAttribute" value="[496, 399]">
    </property>
    <property name="_vergilZoomFactor" class="ptolemy.data.expr.ExpertParameter" value="1.2201304867215976">
    </property>
    <property name="_vergilCenter" class="ptolemy.data.expr.ExpertParameter" value="{466.1590265504499, 266.5908203125}">
    </property>
    <property name="PROJECT_PATH" class="ptolemy.data.expr.Parameter" value="&quot;/Users/hokeunkim/Development/iotauth/&quot;">
        <property name="_hideName" class="ptolemy.kernel.util.SingletonAttribute">
        </property>
        <property name="_icon" class="ptolemy.vergil.icon.ValueIcon">
            <property name="_color" class="ptolemy.actor.gui.ColorAttribute" value="{0.0, 0.0, 1.0, 1.0}">
            </property>
        </property>
        <property name="_smallIconDescription" class="ptolemy.kernel.util.SingletonConfigurableAttribute">
            <configure>
      <svg>
        <text x="20" style="font-size:14; font-family:SansSerif; fill:blue" y="20">-P-</text>
      </svg>
    </configure>
        </property>
        <property name="_editorFactory" class="ptolemy.vergil.toolbox.VisibleParameterEditorFactory">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[275.0, 420.0]">
        </property>
    </property>
    <entity name="Received" class="ptolemy.actor.lib.gui.TimedDisplay">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={916, 614, 499, 208}, maximized=false}">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute" value="[499, 164]">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[450.0, 305.0]">
        </property>
    </entity>
    <entity name="Listening" class="ptolemy.actor.lib.gui.TimedDisplay">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={790, 627, 499, 208}, maximized=false}">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute" value="[499, 164]">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[575.0, 375.0]">
        </property>
    </entity>
    <entity name="Connection" class="ptolemy.actor.lib.gui.TimedDisplay">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={98, 452, 660, 208}, maximized=false}">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute" value="[660, 164]">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[520.0, 360.0]">
        </property>
    </entity>
    <entity name="Error" class="ptolemy.actor.lib.gui.TimedDisplay">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={325, 871, 810, 208}, maximized=false}">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute" value="[499, 164]">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[630.0, 390.0]">
        </property>
    </entity>
    <entity name="KeyId" class="ptolemy.actor.lib.gui.TimedDisplay">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={1100, 753, 499, 208}, maximized=false}">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute" value="[499, 164]">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[535.0, 305.0]">
        </property>
    </entity>
    <entity name="MicrostepDelay" class="ptolemy.actor.lib.MicrostepDelay">
        <property name="_location" class="ptolemy.kernel.util.Location" value="[475.0, 185.0]">
        </property>
        <property name="_hideName" class="ptolemy.data.expr.SingletonParameter" value="true">
        </property>
        <property name="_flipPortsHorizontal" class="ptolemy.data.expr.Parameter" value="true">
        </property>
    </entity>
    <entity name="SessionKey" class="ptolemy.actor.lib.gui.TimedDisplay">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={241, 692, 499, 208}, maximized=false}">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute" value="[499, 164]">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[305.0, 370.0]">
        </property>
    </entity>
    <entity name="RecordAssembler" class="ptolemy.actor.lib.RecordAssembler">
        <property name="_location" class="ptolemy.kernel.util.Location" value="[520.0, 230.0]">
        </property>
        <property name="_hideName" class="ptolemy.data.expr.SingletonParameter" value="true">
        </property>
        <port name="output" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="keyId" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
    </entity>
    <entity name="SecureIoTServer" class="ptolemy.actor.lib.jjs.JavaScript">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="&quot;use strict&quot;;&#10;&#10;var socket = require('socket');&#10;var buffer = require('buffer');&#10;var crypto = require('crypto');&#10;&#10;exports.setup = function () {&#10;    this.input('toSend');&#10;    /*&#10;    this.input('toSendID', {&#10;        type: 'int',&#10;        value: 0&#10;    });&#10;    */&#10;	this.input('sessionKey', {&#10;		type : 'string'&#10;	});&#10;	this.output('keyId', {&#10;		type : 'int'&#10;	});&#10;    this.output('listening', {&#10;        type: 'int'&#10;    });&#10;    this.output('connection');&#10;    this.output('received');&#10;    //this.output('receivedID');&#10;    &#10;    this.parameter('port', {&#10;        type : 'int',&#10;        value : 4000&#10;    });&#10;    &#10;    this.parameter('sessionCipherAlgorithm', {&#10;        value: '',&#10;        type: 'string'&#10;    });&#10;    this.parameter('sessionHashAlgorithm', {&#10;        value: '',&#10;        type: 'string'&#10;    });&#10;/*&#10;    // The parameters below are listed alphabetically.&#10;    this.parameter('clientAuth', {&#10;        type : 'string',&#10;        value : 'none'    // Indicates no SSL/TSL will be used.&#10;    });&#10;    this.parameter('discardSendToUnopenedSocket', {&#10;        type : 'boolean',&#10;        value : false&#10;    });&#10;    this.parameter('hostInterface', {&#10;        type : 'string',&#10;        value : '0.0.0.0' // Means listen on all available interfaces.&#10;    });&#10;    this.parameter('idleTimeout', {&#10;        value: 0,         // In seconds. 0 means don't timeout.&#10;        type: &quot;int&quot;&#10;    });&#10;    this.parameter('keepAlive', {&#10;        type : 'boolean',&#10;        value : true&#10;    });&#10;    this.parameter('noDelay', {&#10;        type : 'boolean',&#10;        value : true&#10;    });&#10;    this.parameter('pfxKeyCertPassword', {&#10;        type : 'string',&#10;        value : ''&#10;    });&#10;    this.parameter('pfxKeyCertPath', {&#10;        type : 'string',&#10;        value : ''&#10;    });&#10;    this.parameter('port', {&#10;        type : 'int',&#10;        value : 4000&#10;    });&#10;    this.parameter('rawBytes', {&#10;        type : 'boolean',&#10;        value : false      // Means to use a messaging protocol.&#10;    });&#10;    this.parameter('receiveBufferSize', {&#10;        value: 65536,&#10;        type: &quot;int&quot;&#10;    });&#10;    this.parameter('receiveType', {&#10;        type : 'string',&#10;        value : 'string',&#10;    });&#10;    this.parameter('sendBufferSize', {&#10;        value: 65536,&#10;        type: &quot;int&quot;&#10;    });&#10;    this.parameter('sendType', {&#10;        type : 'string',&#10;        value : 'string',&#10;    });&#10;    this.parameter('sslTls', {&#10;        type : 'boolean',&#10;        value : false&#10;    });&#10;    this.parameter('trustedCACertPath', {&#10;        type : 'string',&#10;        value : ''&#10;    });&#10;    // Attempt to add a list of options for types, but do not error out&#10;    // if the socket module is not supported by the host.&#10;    try {&#10;        this.parameter('receiveType', {&#10;            options : socket.supportedReceiveTypes()&#10;        });&#10;        this.parameter('sendType', {&#10;            options : socket.supportedSendTypes()&#10;        });&#10;    } catch(err) {&#10;        error(err);&#10;    }&#10;    */&#10;};&#10;&#10;&#10;var msgType = {&#10;    SKEY_HANDSHAKE_1: 30,&#10;    SKEY_HANDSHAKE_2: 31,&#10;    SKEY_HANDSHAKE_3: 32,&#10;    SECURE_COMM_MSG: 33,&#10;    FIN_SECURE_COMM: 34,&#10;    SECURE_PUB: 40&#10;};&#10;var HS_NONCE_SIZE = 8;            // handshake nonce size&#10;var S_KEY_ID_SIZE = 8;&#10;var SEQ_NUM_SIZE = 8;&#10;&#10;// verialbe length integer encoding&#10;function numToVarLenInt(num) {&#10;    var buf = new buffer.Buffer(0);&#10;    while (num &gt; 127) {&#10;        var extraBuf = new buffer.Buffer(1);&#10;        extraBuf.writeUInt8(128 | num &amp; 127);&#10;        buf = buffer.concat([buf, extraBuf]);&#10;        num &gt;&gt;= 7;&#10;    }&#10;    var extraBuf = new buffer.Buffer(1);&#10;    extraBuf.writeUInt8(num);&#10;    buf = buffer.concat([buf, extraBuf]);&#10;    return buf;&#10;};&#10;&#10;function varLenIntToNum(buf, offset) {&#10;    var num = 0;&#10;    for (var i = 0; i &lt; buf.length &amp;&amp; i &lt; 5; i++) {&#10;        num |= (buf.get(offset + i) &amp; 127) &lt;&lt; (7 * i);&#10;        if ((buf.get(offset + i) &amp; 128) == 0) {&#10;            return {num: num, bufLen: i + 1};&#10;            break;&#10;        }&#10;    }&#10;    return null;&#10;};&#10;&#10;/*&#10;    IoTSP (IoT Secure Protocol) Message&#10;    {&#10;        msgType: /UInt8/,&#10;        payloadLen: /variable-length integer encoding/&#10;        payload: /Buffer/&#10;    }&#10;*/&#10;var serializeIoTSP = function(obj) {&#10;    if (obj.msgType == undefined || obj.payload == undefined) {&#10;        console.log('Error: IoTSP msgType or payload is missing.');&#10;        return;&#10;    }&#10;    var msgTypeBuf = new buffer.Buffer(1);&#10;    msgTypeBuf.writeUInt8(obj.msgType, 0);&#10;    var payLoadLenBuf = numToVarLenInt(obj.payload.length);&#10;    return buffer.concat([msgTypeBuf, payLoadLenBuf, obj.payload]);&#10;};&#10;&#10;var parseIoTSP = function(buf) {&#10;    var msgTypeVal = buf.readUInt8(0);&#10;    var ret = varLenIntToNum(buf, 1);&#10;    var payloadVal = buf.slice(1 + ret.bufLen);&#10;    return {msgType: msgTypeVal, payloadLen: ret.num, payload: payloadVal};&#10;};&#10;&#10;/*&#10;    Handshake Format&#10;    {&#10;        nonce: /Buffer/, // encrypted, may be undefined&#10;        replyNonce: /Buffer/, // encrypted, may be undefined&#10;    }&#10;*/&#10;var serializeHandshake = function(obj) {&#10;    if (obj.nonce == undefined &amp;&amp; obj.replyNonce == undefined) {&#10;        console.log('Error: handshake should include at least on nonce.');&#10;        return;&#10;    }&#10;    var buf = new buffer.Buffer(1 + HS_NONCE_SIZE * 2);&#10;&#10;    // indicates existance of nonces&#10;    var indicator = 0;&#10;    if (obj.nonce != undefined) {&#10;        indicator += 1;&#10;        obj.nonce.copy(buf, 1);&#10;    }&#10;    if (obj.replyNonce != undefined) {&#10;        indicator += 2;&#10;        obj.replyNonce.copy(buf, 1 + HS_NONCE_SIZE);&#10;    }&#10;    buf.writeUInt8(indicator, 0);&#10;&#10;    return buf;&#10;};&#10;&#10;// buf should be just the unencrypted part&#10;var parseHandshake = function(buf) {&#10;    var obj = {};&#10;    var indicator = buf.readUInt8(0);&#10;    if ((indicator &amp; 1) != 0) {&#10;        // nonce exists&#10;        obj.nonce = buf.slice(1, 1 + HS_NONCE_SIZE);&#10;    }&#10;    if ((indicator &amp; 2) != 0) {&#10;        // replayNonce exists&#10;        obj.replyNonce = buf.slice(1 + HS_NONCE_SIZE, 1 + HS_NONCE_SIZE * 2);&#10;    }&#10;    return obj;&#10;};&#10;&#10;/*&#10;    SecureSessionMessage Format&#10;    {&#10;        SeqNum: /Buffer/, // UIntBE, SEQ_NUM_SIZE Bytes&#10;        data: /Buffer/,&#10;    }&#10;*/&#10;var serializeSessionMessage = function(obj) {&#10;    if (obj.seqNum == undefined || obj.data == undefined) {&#10;        console.log('Error: Secure session message seqNum or data is missing.');&#10;        return;&#10;    }&#10;    var seqNumBuf = new buffer.Buffer(SEQ_NUM_SIZE);&#10;    seqNumBuf.writeUIntBE(obj.seqNum, 0, SEQ_NUM_SIZE);&#10;    return buffer.concat([seqNumBuf, obj.data]);&#10;};&#10;var parseSessionMessage = function(buf) {&#10;    var seqNum = buf.readUIntBE(0, SEQ_NUM_SIZE);&#10;    var data = buf.slice(SEQ_NUM_SIZE);&#10;    return {seqNum: seqNum, data: data};&#10;};&#10;//////////////// end of common code&#10;&#10;// crypto info&#10;var sessionCipherAlgorithm;&#10;var sessionHashAlgorithm;&#10;&#10;&#10;// server communication state&#10;var serverCommState = {&#10;    IDLE: 0,&#10;    WAITING_SESSION_KEY: 20,&#10;    HANDSHAKE_1_RECEIVED: 21,&#10;    HANDSHAKE_2_SENT: 22,&#10;    IN_COMM: 30                    // Session message&#10;};&#10;&#10;// local variables&#10;var server = null;&#10;var connectionCount = 0;&#10;var sockets = [];&#10;var self;&#10;var sessionKey = null;&#10;var currentState = serverCommState.IDLE;&#10;var writeSeqNum = 0;&#10;var readSeqNum = 0;&#10;&#10;var lastClientState = {&#10;	serverSocket: null,&#10;	myNonce: null,&#10;	obj: null,&#10;	keyId: 100&#10;};&#10;&#10;function reportError(errorMessage) {&#10;	console.log(errorMessage);&#10;	self.send('error', errorMessage);&#10;};&#10;&#10;&#10;&#10;	    &#10;function sendHandshake2(obj, serverSocket) {&#10;	if (currentState != serverCommState.HANDSHAKE_1_RECEIVED) {&#10;		reportError('in wrong state, expected: HANDSHAKE_1_RECEIVED, disconnecting...');&#10;		currentState = serverCommState.IDLE;&#10;		lastClientState.serverSocket.close();&#10;		return;&#10;	}&#10;    var enc = obj.payload.slice(S_KEY_ID_SIZE);&#10;    var ret = crypto.symmetricDecryptWithHash(enc.getArray(), sessionKey.val,&#10;    	sessionCipherAlgorithm, sessionHashAlgorithm);&#10;    if (!ret.hashOk) {&#10;    	reportError('received hash for handshake 1 is NOT ok');&#10;    }&#10;    console.log('received hash for handshake 1 is ok');&#10;    var buf = new buffer.Buffer(ret.data);&#10;    &#10;    var handshake1 = parseHandshake(buf);&#10;    &#10;	var myNonce = new buffer.Buffer(crypto.randomBytes(HS_NONCE_SIZE));&#10;    console.log('chosen nonce: ' + myNonce.inspect());&#10;    &#10;    var theirNonce = handshake1.nonce;&#10;    &#10;    var handshake2 = {nonce: myNonce, replyNonce: theirNonce};&#10;    &#10;    var encBuf = crypto.symmetricEncryptWithHash(serializeHandshake(handshake2).getArray(),&#10;        sessionKey.val, sessionCipherAlgorithm, sessionHashAlgorithm);&#10;    var msg = {&#10;    	msgType: msgType.SKEY_HANDSHAKE_2,&#10;    	payload: new buffer.Buffer(encBuf)&#10;    };&#10;    var toSend = serializeIoTSP(msg).getArray();&#10;    &#10;    lastClientState.myNonce = myNonce;&#10;    &#10;	console.log('switching to HANDSHAKE_2_SENT state.');&#10;	currentState = serverCommState.HANDSHAKE_2_SENT;&#10;    &#10;    serverSocket.send(toSend);&#10;};&#10;&#10;exports.sessionKeyInputHandler = function() {&#10;	console.log('sessionKey arrived');&#10;	if (currentState != serverCommState.WAITING_SESSION_KEY) {&#10;		reportError('in wrong state, expected: WAITING_SESSION_KEY, disconnecting...');&#10;		currentState = serverCommState.IDLE;&#10;		if (lastClientState.serverSocket != null) {&#10;			lastClientState.serverSocket.close();&#10;		}&#10;		return;&#10;	}&#10;	&#10;	var receivedSessionKey = JSON.parse(self.get('sessionKey'));&#10;	receivedSessionKey.absValidity = new Date(receivedSessionKey.absValidity);&#10;	&#10;	if (receivedSessionKey.id == lastClientState.keyId) {&#10;		console.log('sessionKey id is as expected');&#10;		sessionKey = receivedSessionKey;&#10;		console.log('switching to HANDSHAKE_1_RECEIVED state.');&#10;		currentState = serverCommState.HANDSHAKE_1_RECEIVED;&#10;    	sendHandshake2(lastClientState.obj, lastClientState.serverSocket);&#10;	}&#10;	else {&#10;		reportError('sessionKey id is NOT as expected');&#10;	}&#10;};&#10;&#10;function initServer(port) {&#10;    server = new socket.SocketServer(&#10;        {&#10;            //'clientAuth' : this.getParameter('clientAuth'),&#10;        	'emitBatchDataAsAvailable' : true,&#10;            //'hostInterface' : this.getParameter('hostInterface'),&#10;            //'idleTimeout' : this.getParameter('idleTimeout'),&#10;            //'keepAlive' : false,&#10;            //'noDelay' : this.getParameter('noDelay'),&#10;            //'pfxKeyCertPassword' : this.getParameter('pfxKeyCertPassword'),&#10;            //'pfxKeyCertPath' : this.getParameter('pfxKeyCertPath'),&#10;            'port' : port,&#10;            'rawBytes' : true,&#10;            //'receiveBufferSize' : this.getParameter('receiveBufferSize'),&#10;            'receiveType' : 'byte',&#10;            //'sendBufferSize' : this.getParameter('sendBufferSize'),&#10;            'sendType' : 'byte',&#10;            //'sslTls' : this.getParameter('sslTls'),&#10;            //'trustedCACertPath' : this.getParameter('trustedCACertPath')&#10;        }&#10;    );&#10;&#10;    server.on('error', function(message) {&#10;        self.error(message);&#10;    });&#10;        &#10;    server.on('listening', function(port) {&#10;        console.log('Server: Listening for socket connection requests on port ' + port);&#10;        self.send('listening', port);&#10;    });&#10;    &#10;    server.on('connection', function(serverSocket) {&#10;    	console.log('client connected');&#10;    	// serverSocket is an instance of the Socket class defined&#10;    	// in the socket module.&#10;    	connectionCount++;&#10;        var socketInstance = connectionCount;&#10;        var socketID = {&#10;            'id': socketInstance,&#10;            'remoteHost': serverSocket.remoteHost(),&#10;            'remotePort': serverSocket.remotePort(),&#10;            'status': 'open'&#10;        };&#10;        self.send('connection', socketID);&#10;        &#10;        sockets[socketInstance] = serverSocket;&#10;&#10;        serverSocket.on('close', function() {&#10;			console.log('switching to IDLE state.');&#10;        	currentState = serverCommState.IDLE;&#10;            socketID.status = 'closed';&#10;            self.send('connection', socketID);&#10;            // Avoid a memory leak here.&#10;            sockets[socketInstance] = null;&#10;        });&#10;        &#10;        serverSocket.on('error', function(message) {&#10;            self.error(message);&#10;        });&#10;        &#10;        var expectingMoreData = false;&#10;        serverSocket.on('data', function(data) {&#10;            console.log('received data from client');&#10;            var buf = new buffer.Buffer(data);&#10;            var obj;&#10;            if (!expectingMoreData) {&#10;            	obj = parseIoTSP(buf);&#10;            	if (obj.payload.length &lt; obj.payloadLen) {&#10;            		expectingMoreData = true;&#10;                	console.log('more data will come. current: ' + obj.payload.length&#10;                    	+ ' expected: ' + obj.payloadLen);&#10;            	}&#10;            }&#10;       	 	else {&#10;	            obj.payload = buffer.concat([obj.payload, new buffer.Buffer(data)]);&#10;	            if (obj.payload.length ==  obj.payloadLen) {&#10;	                expectingMoreData = false;&#10;	            }&#10;	            else {&#10;	                console.log('more data will come. current: ' + obj.payload.length&#10;	                    + ' expected: ' + obj.payloadLen);&#10;	            }&#10;	        }&#10;	        &#10;	        if (expectingMoreData) {&#10;	            // do not process the packet yet&#10;	            return;&#10;	        }&#10;	        else if (obj.msgType == msgType.SKEY_HANDSHAKE_1) {&#10;	            console.log('received session key handshake1');&#10;	            var keyId = obj.payload.readUIntBE(0, S_KEY_ID_SIZE);&#10;	            lastClientState.obj = obj;&#10;	            lastClientState.keyId = keyId;&#10;	            lastClientState.serverSocket = serverSocket;&#10;    			&#10;	            if (sessionKey != null &amp;&amp; sessionKey.id == keyId) {&#10;        			console.log('switching to HANDSHAKE_1_RECEIVED state.');&#10;        			currentState = serverCommState.HANDSHAKE_1_RECEIVED;&#10;	            	sendHandshake2();&#10;	            }&#10;	            else {&#10;                	console.log('session key NOT found! sending session key id to AuthService');&#10;        			console.log('switching to WAITING_SESSION_KEY state.');&#10;        			currentState = serverCommState.WAITING_SESSION_KEY;&#10;		    		self.send('keyId', keyId);&#10;	            }&#10;	        }&#10;	        else if (obj.msgType == msgType.SKEY_HANDSHAKE_3) {&#10;	            console.log('received session key handshake3');&#10;				if (currentState != serverCommState.HANDSHAKE_2_SENT) {&#10;					reportError('in wrong state, expected: HANDSHAKE_2_SENT, disconnecting...');&#10;					currentState = serverCommState.IDLE;&#10;					serverSocket.close();&#10;					return;&#10;				}&#10;			    var ret = crypto.symmetricDecryptWithHash(obj.payload.getArray(), sessionKey.val,&#10;			    	sessionCipherAlgorithm, sessionHashAlgorithm);&#10;			    if (!ret.hashOk) {&#10;			    	reportError('received hash for handshake 3 is NOT ok');&#10;			    }&#10;			    console.log('received hash for handshake 3 is ok');&#10;			    var buf = new buffer.Buffer(ret.data);&#10;			    var handshake3 = parseHandshake(buf);&#10;			    if (!handshake3.replyNonce.equals(lastClientState.myNonce)) {&#10;			    	reportError('client nonce NOT verified');&#10;			    	return;&#10;			    }&#10;		    	console.log('client nonce verified');&#10;		    	&#10;    			console.log('switching to IN_COMM state.');&#10;    			currentState = serverCommState.IN_COMM;&#10;	        }&#10;	        else if (obj.msgType == msgType.SECURE_COMM_MSG) {&#10;	            console.log('received secure communication message');&#10;				if (currentState != serverCommState.IN_COMM) {&#10;					reportError('in wrong state, expected: IN_COMM, disconnecting...');&#10;					currentState = serverCommState.IDLE;&#10;					serverSocket.close();&#10;					return;&#10;				}&#10;			    var ret = crypto.symmetricDecryptWithHash(obj.payload.getArray(), sessionKey.val,&#10;			    	sessionCipherAlgorithm, sessionHashAlgorithm);&#10;			    if (!ret.hashOk) {&#10;			    	reportError('received hash for secure communication message is NOT ok');&#10;			    }&#10;			    console.log('received hash for secure communication message is ok');&#10;	        	ret = parseSessionMessage(new buffer.Buffer(ret.data));&#10;	        	console.log('seqNum: ' + ret.seqNum + ' data: ' + ret.data.toString());&#10;	        	&#10;	        	if (ret.seqNum != readSeqNum) {&#10;	        		console.log('wrong seqNum. expected: ' + readSeqNum);&#10;	        	}&#10;	        	readSeqNum++;&#10;	        	&#10;	            self.send('received', ret.data.toString());&#10;	            //self.send('receivedID', connectionCount);&#10;	        }&#10;        });&#10;    });&#10;    &#10;    // Open the server after setting up all the handlers.&#10;    server.start();&#10;};&#10;&#10;exports.initialize = function () {&#10;	currentState = serverCommState.IDLE;&#10;    writeSeqNum = 0;&#10;    readSeqNum = 0;&#10;	sessionKey = null;&#10;	&#10;	sessionCipherAlgorithm = this.getParameter('sessionCipherAlgorithm');&#10;	sessionHashAlgorithm = this.getParameter('sessionHashAlgorithm');&#10;	&#10;    self = this;&#10;	initServer(this.getParameter('port'));&#10;    &#10;    // Bind the input handler to caller's object so that when it is invoked,&#10;    // it is invoked in the context of that object and not this one.&#10;    &#10;    this.addInputHandler('sessionKey', exports.sessionKeyInputHandler.bind(this));&#10;    //this.addInputHandler('toSend', exports.toSendInputHandler.bind(this));&#10;};&#10;&#10;/** Close all sockets, unregister event listeners, and stop the server.&#10; */&#10;exports.wrapup = function() {&#10;    sockets = [];&#10;&#10;    if (server !== null) {&#10;        server.stop();&#10;        server = null;&#10;    }&#10;};&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[379.875, 259.75]">
        </property>
        <property name="port" class="ptolemy.data.expr.Parameter" value="21200">
        </property>
        <property name="sessionCipherAlgorithm" class="ptolemy.data.expr.Parameter" value="AES-128-CBC">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="sessionHashAlgorithm" class="ptolemy.data.expr.Parameter" value="SHA-256">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <port name="toSend" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="sessionKey" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="keyId" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
        <port name="listening" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_cardinal" class="ptolemy.kernel.util.StringAttribute" value="SOUTH">
            </property>
        </port>
        <port name="connection" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_cardinal" class="ptolemy.kernel.util.StringAttribute" value="SOUTH">
            </property>
        </port>
        <port name="received" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
    </entity>
    <entity name="IoTAuthService" class="ptolemy.actor.lib.jjs.JavaScript">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="&quot;use strict&quot;;&#10;&#10;var socket = require('socket');&#10;var buffer = require('buffer');&#10;var crypto = require('crypto');&#10;&#10;exports.setup = function() {&#10;	this.input('purpose');&#10;	this.output('sessionKey', {&#10;		type : 'string'&#10;	});&#10;	&#10;	this.parameter('authHost', {&#10;        type : 'string',&#10;        value : 'localhost'&#10;    });&#10;    this.parameter('authPort', {&#10;        value: -1,&#10;        type: 'int'&#10;    });&#10;    this.parameter('authCertPath', {&#10;        value: '',&#10;        type: 'string'&#10;    });&#10;    &#10;    this.parameter('entityName', {&#10;        value: '',&#10;        type: 'string'&#10;    });&#10;    this.parameter('entityPrivateKeyPath', {&#10;        value: '',&#10;        type: 'string'&#10;    });&#10;    &#10;    this.parameter('publicCipherAlgorithm', {&#10;        value: '',&#10;        type: 'string'&#10;    });&#10;    this.parameter('signAlgorithm', {&#10;        value: '',&#10;        type: 'string'&#10;    });&#10;    this.parameter('distCipherAlgorithm', {&#10;        value: '',&#10;        type: 'string'&#10;    });&#10;    this.parameter('distHashAlgorithm', {&#10;        value: '',&#10;        type: 'string'&#10;    });&#10;};&#10;&#10;//////////////// beginning of common code&#10;var msgType = {&#10;    AUTH_HELLO: 0,&#10;    AUTH_SESSION_KEY_REQ: 10,&#10;    AUTH_SESSION_KEY_RESP: 11,&#10;    SESSION_KEY_REQ_IN_PUB_ENC: 20,&#10;    SESSION_KEY_RESP_WITH_DIST_KEY: 21,    // Includes distribution message (session keys)&#10;    SESSION_KEY_REQ: 22,         // Distribution message&#10;    SESSION_KEY_RESP: 23         // Distribution message&#10;};&#10;&#10;var AUTH_NONCE_SIZE = 8;&#10;var S_KEY_ID_SIZE = 8;&#10;var ABS_VALIDITY_SIZE = 6;&#10;var REL_VALIDITY_SIZE = 6;&#10;var DIST_CIPHER_KEY_SIZE = 16;               // 256 bit key = 32 bytes&#10;var SESSION_CIPHER_KEY_SIZE = 16;            // 128 bit key = 16 bytes&#10;&#10;// verialbe length integer encoding&#10;function numToVarLenInt(num) {&#10;    var buf = new buffer.Buffer(0);&#10;    while (num &gt; 127) {&#10;        var extraBuf = new buffer.Buffer(1);&#10;        extraBuf.writeUInt8(128 | num &amp; 127);&#10;        buf = buffer.concat([buf, extraBuf]);&#10;        num &gt;&gt;= 7;&#10;    }&#10;    var extraBuf = new buffer.Buffer(1);&#10;    extraBuf.writeUInt8(num);&#10;    buf = buffer.concat([buf, extraBuf]);&#10;    return buf;&#10;};&#10;&#10;function varLenIntToNum(buf, offset) {&#10;    var num = 0;&#10;    for (var i = 0; i &lt; buf.length &amp;&amp; i &lt; 5; i++) {&#10;        num |= (buf.get(offset + i) &amp; 127) &lt;&lt; (7 * i);&#10;        if ((buf.get(offset + i) &amp; 128) == 0) {&#10;            return {num: num, bufLen: i + 1};&#10;            break;&#10;        }&#10;    }&#10;    return null;&#10;};&#10;&#10;var serializeIoTSP = function(obj) {&#10;    if (obj.msgType == undefined || obj.payload == undefined) {&#10;        console.log('Error: IoTSP msgType or payload is missing.');&#10;        return;&#10;    }&#10;    var msgTypeBuf = new buffer.Buffer(1);&#10;    msgTypeBuf.writeUInt8(obj.msgType, 0);&#10;    var payLoadLenBuf = numToVarLenInt(obj.payload.length);&#10;    return buffer.concat([msgTypeBuf, payLoadLenBuf, obj.payload]);&#10;};&#10;&#10;var parseIoTSP = function(buf) {&#10;    var msgTypeVal = buf.readUInt8(0);&#10;    var ret = varLenIntToNum(buf, 1);&#10;    var payloadVal = buf.slice(1 + ret.bufLen);&#10;    return {msgType: msgTypeVal, payloadLen: ret.num, payload: payloadVal};&#10;};&#10;&#10;var parseAuthHello = function(buf) {&#10;    var authId = buf.readUInt32BE(0);&#10;    var nonce = buf.slice(4, 4 + AUTH_NONCE_SIZE);&#10;    return {authId: authId, nonce: nonce};&#10;};&#10;&#10;var serializeSessionKeyReq = function(obj) {&#10;    if (obj.nonce == undefined || obj.replyNonce == undefined || obj.sender == undefined&#10;        || obj.purpose == undefined || obj.numKeys == undefined) {&#10;        console.log('Error: SessionKeyReq nonce or replyNonce '&#10;            + 'or purpose or numKeys is missing.');&#10;        return;&#10;    }&#10;    var buf = new buffer.Buffer(AUTH_NONCE_SIZE * 2 + 5);&#10;    obj.nonce.copy(buf, 0);&#10;    obj.replyNonce.copy(buf, AUTH_NONCE_SIZE);&#10;    buf.writeUInt32BE(obj.numKeys, AUTH_NONCE_SIZE * 2);&#10;    buf.writeUInt8(obj.sender.length, AUTH_NONCE_SIZE * 2 + 4);&#10;&#10;    var senderBuf = new buffer.Buffer(obj.sender);&#10;    var purposeBuf = new buffer.Buffer(JSON.stringify(obj.purpose));&#10;    return buffer.concat([buf, senderBuf, purposeBuf]);&#10;};&#10;&#10;var serializeSessionKeyReqWithDistributionKey = function(senderName,&#10;    sessionKeyReq, distributionKeyVal, cipherAlgorithm, hashAlgorithm) {&#10;    var sessionKeyReqBuf = serializeSessionKeyReq(sessionKeyReq);&#10;    var encBuf = new buffer.Buffer(crypto.symmetricEncryptWithHash(sessionKeyReqBuf.getArray(),&#10;    	distributionKeyVal, cipherAlgorithm, hashAlgorithm));&#10;&#10;    var senderBuf = new buffer.Buffer(senderName);&#10;    var lengthBuf = new buffer.Buffer(1);&#10;    lengthBuf.writeUInt8(senderBuf.length);&#10;    return buffer.concat([lengthBuf, senderBuf, encBuf]);&#10;};&#10;&#10;var parseDistributionKey = function(buf) {&#10;    var absValidity = new Date(buf.readUIntBE(0, ABS_VALIDITY_SIZE));&#10;    var keyVal = buf.slice(ABS_VALIDITY_SIZE, ABS_VALIDITY_SIZE + DIST_CIPHER_KEY_SIZE);&#10;    return {val: keyVal, absValidity: absValidity};&#10;};&#10;&#10;var parseSessionKey = function(buf) {&#10;    var keyId = buf.readUIntBE(0, S_KEY_ID_SIZE);&#10;    var absValidityValue = buf.readUIntBE(S_KEY_ID_SIZE, ABS_VALIDITY_SIZE);&#10;    var absValidity = new Date(buf.readUIntBE(S_KEY_ID_SIZE, ABS_VALIDITY_SIZE));&#10;    var relValidity = buf.readUIntBE(S_KEY_ID_SIZE + ABS_VALIDITY_SIZE, REL_VALIDITY_SIZE);&#10;    var curIndex =  S_KEY_ID_SIZE + ABS_VALIDITY_SIZE + REL_VALIDITY_SIZE;&#10;    var keyVal = buf.slice(curIndex, curIndex + SESSION_CIPHER_KEY_SIZE);&#10;    return {id: keyId, val: keyVal, absValidity: absValidity, relValidity: relValidity};&#10;};&#10;&#10;var SESSION_KEY_BUF_SIZE = S_KEY_ID_SIZE + ABS_VALIDITY_SIZE + REL_VALIDITY_SIZE + SESSION_CIPHER_KEY_SIZE;&#10;var parseSessionKeyResp = function(buf) {&#10;    var replyNonce = buf.slice(0, AUTH_NONCE_SIZE);&#10;    var bufIdx = AUTH_NONCE_SIZE;&#10;    &#10;	var cryptoSpecLen = buf.readUInt8(bufIdx);&#10;	bufIdx += 1;&#10;	var cryptoSpecStr = buf.toString(bufIdx, bufIdx + cryptoSpecLen);&#10;	bufIdx += cryptoSpecLen;&#10;	&#10;    var sessionKeyCount = buf.readUInt32BE(bufIdx);&#10;&#10;    bufIdx += 4;&#10;    var sessionKeyList = [];&#10;    for (var i = 0; i &lt; sessionKeyCount; i++) {&#10;        var sessionKey = parseSessionKey(buf.slice(bufIdx));&#10;        sessionKeyList.push(sessionKey);&#10;        bufIdx += SESSION_KEY_BUF_SIZE;&#10;    }&#10;    return {replyNonce: replyNonce, sessionKeyList: sessionKeyList};&#10;};&#10;//////////////// end of common code&#10;&#10;// auth and entity info&#10;var authPublicKey;&#10;var entityPrivateKey;&#10;var entityName;&#10;&#10;// crypto info&#10;var publicCipherAlgorithm;&#10;var signAlgorithm;&#10;var distCipherAlgorithm;&#10;var distHashAlgorithm;&#10;&#10;// local variables&#10;var self;&#10;var client = null;&#10;var distributionKey = null;&#10;var sessionKeyList = [];&#10;&#10;function outputSessionKey(sessionKey) {&#10;	sessionKey.val = sessionKey.val.getArray();&#10;    self.send('sessionKey', JSON.stringify(sessionKey));&#10;};&#10;&#10;function handleSessionKeyResp(obj, myNonce) {&#10;	if (obj.msgType == msgType.SESSION_KEY_RESP_WITH_DIST_KEY) {&#10;        console.log('received session key response with distribution key attached!');&#10;        var distKeyBuf = obj.payload.slice(0, 512);&#10;        var sessionKeyRespBuf = obj.payload.slice(512);&#10;        var pubEncData = distKeyBuf.slice(0, 256).getArray();&#10;        var signature = distKeyBuf.slice(256).getArray();&#10;        var verified = crypto.verifySignature(pubEncData, signature, authPublicKey, signAlgorithm);&#10;        if (!verified) {&#10;        	console.log('Auth signature NOT verified');&#10;        	return;&#10;        }&#10;    	console.log('Auth signature verified');&#10;    	distKeyBuf = new buffer.Buffer(&#10;    		crypto.privateDecrypt(pubEncData, entityPrivateKey, publicCipherAlgorithm));&#10;    	var receivedDistKey = parseDistributionKey(distKeyBuf);&#10;    	&#10;        var ret = crypto.symmetricDecryptWithHash(sessionKeyRespBuf.getArray(),&#10;        	receivedDistKey.val.getArray(), distCipherAlgorithm, distHashAlgorithm);&#10;        if (!ret.hashOk) {&#10;        	console.log('Received hash for session key resp is NOT ok');&#10;        	return;&#10;        }&#10;    	console.log('Received hash for session key resp is ok');&#10;    	sessionKeyRespBuf = new buffer.Buffer(ret.data);&#10;    	var sessionKeyResp = parseSessionKeyResp(sessionKeyRespBuf);&#10;    	if (!sessionKeyResp.replyNonce.equals(myNonce)) {&#10;        	console.log('Auth nonce NOT verified');&#10;        	return;&#10;    	}&#10;    	console.log('Auth nonce verified');&#10;    	&#10;    	console.log('Updating to a new distribution key key');&#10;    	distributionKey = receivedDistKey;&#10;    	console.log(distributionKey);&#10;    	&#10;    	console.log('received ' + sessionKeyResp.sessionKeyList.length + ' session keys');&#10;    	for (var i = 0; i &lt; sessionKeyResp.sessionKeyList.length; i++) {&#10;    		sessionKeyList.push(sessionKeyResp.sessionKeyList[i]);&#10;    	}&#10;    	console.log('Status: Connection closed after receiving auth response.');&#10;	}&#10;	else if (obj.msgType == msgType.SESSION_KEY_RESP) {&#10;		console.log('received session key response encrypted with distribution key');&#10;		var ret = crypto.symmetricDecryptWithHash(obj.payload.getArray(),&#10;        	distributionKey.val.getArray(), distCipherAlgorithm, distHashAlgorithm);&#10;        if (!ret.hashOk) {&#10;        	console.log('Received hash for session key resp is NOT ok');&#10;        	return;&#10;        }&#10;    	console.log('Received hash for session key resp is ok');&#10;        var decBuf = new buffer.Buffer(ret.data);&#10;        var sessionKeyResp = parseSessionKeyResp(decBuf);&#10;    	if (!sessionKeyResp.replyNonce.equals(myNonce)) {&#10;        	console.log('Auth nonce NOT verified');&#10;        	return;&#10;    	}&#10;    	console.log('Auth nonce verified');&#10;    	&#10;    	for (var i = 0; i &lt; sessionKeyResp.sessionKeyList.length; i++) {&#10;    		sessionKeyList.push(sessionKeyResp.sessionKeyList[i]);&#10;    	}&#10;    	console.log('Status: Connection closed after receiving auth response.');&#10;	}&#10;	if (sessionKeyList.length &gt; 0) {&#10;		outputSessionKey(sessionKeyList.shift());&#10;	}&#10;};&#10;&#10;function sendSessionKeyReq(authHost, authPort, numKeys, purpose) {&#10;	if (client) {&#10;		// Either the host or the port has changed. Close the previous socket.&#10;		client.close();&#10;	}&#10;    client = new socket.SocketClient(authPort, authHost,&#10;    {&#10;        //'connectTimeout' : this.getParameter('connectTimeout'),&#10;        'discardMessagesBeforeOpen' : false,&#10;        'emitBatchDataAsAvailable' : true,&#10;        //'idleTimeout' : this.getParameter('idleTimeout'),&#10;        'keepAlive' : false,&#10;        //'maxUnsentMessages' : this.getParameter('maxUnsentMessages'),&#10;        //'noDelay' : this.getParameter('noDelay'),&#10;        //'pfxKeyCertPassword' : this.getParameter('pfxKeyCertPassword'),&#10;        //'pfxKeyCertPath' : this.getParameter('pfxKeyCertPath'),&#10;        'rawBytes' : true,&#10;        //'receiveBufferSize' : this.getParameter('receiveBufferSize'),&#10;        'receiveType' : 'byte',&#10;        //'reconnectAttempts' : this.getParameter('reconnectAttempts'),&#10;        //'reconnectInterval' : this.getParameter('reconnectInterval'),&#10;        //'sendBufferSize' : this.getParameter('sendBufferSize'),&#10;        'sendType' : 'byte',&#10;        //'sslTls' : this.getParameter('sslTls'),&#10;        //'trustAll' : this.getParameter('trustAll'),&#10;        //'trustedCACertPath' : this.getParameter('trustedCACertPath')&#10;    });&#10;    client.on('open', function() {&#10;    	console.log('connected to auth');&#10;    });&#10;    var myNonce;&#10;    client.on('data', function(data) {&#10;    	console.log('data received from auth');&#10;		var buf = new buffer.Buffer(data);&#10;		var obj = parseIoTSP(buf);&#10;		if (obj.msgType == msgType.AUTH_HELLO) {&#10;			var authHello = parseAuthHello(obj.payload);&#10;			myNonce = new buffer.Buffer(crypto.randomBytes(AUTH_NONCE_SIZE));&#10;		&#10;            var sessionKeyReq = {&#10;                nonce: myNonce,&#10;                replyNonce: authHello.nonce,&#10;                numKeys: numKeys,&#10;                sender: entityName,&#10;                purpose: purpose&#10;            };&#10;			var msg;&#10;            if (distributionKey == null || distributionKey.absValidity &lt; new Date()) {&#10;                if (distributionKey != null) {&#10;                    console.log('current distribution key expired, '&#10;                        + 'requesting new distribution key as well...');&#10;                }&#10;                else {&#10;                    console.log('no distribution key available yet, '&#10;                        + 'requesting new distribution key as well...');&#10;                }&#10;	            var sessionKeyReqBuf = serializeSessionKeyReq(sessionKeyReq);&#10;	            var payload = new buffer.Buffer(&#10;	            	crypto.publicEncryptAndSign(sessionKeyReqBuf.getArray(),&#10;	            	authPublicKey, entityPrivateKey,&#10;	            	publicCipherAlgorithm, signAlgorithm));&#10;	            msg = {&#10;	            	msgType: msgType.SESSION_KEY_REQ_IN_PUB_ENC,&#10;	            	payload: payload&#10;	            };&#10;            }&#10;            else {&#10;                console.log('distribution key available! ');&#10;                msg = {&#10;                	msgType: msgType.SESSION_KEY_REQ,&#10;                	payload: serializeSessionKeyReqWithDistributionKey(entityName,&#10;                		sessionKeyReq, distributionKey.val.getArray(), distCipherAlgorithm, distHashAlgorithm)&#10;                };&#10;            }&#10;            var toSend = serializeIoTSP(msg).getArray();&#10;            client.send(toSend);&#10;		}&#10;		else if (obj.msgType == msgType.SESSION_KEY_RESP_WITH_DIST_KEY ||&#10;		    obj.msgType == msgType.SESSION_KEY_RESP) {&#10;	    	handleSessionKeyResp(obj, myNonce);&#10;	    	client.close();&#10;		}&#10;    });&#10;    client.on('close', function() {&#10;    	console.log('disconnected from auth');&#10;    });&#10;    client.on('error', function(message) {&#10;    	console.log('an error occurred');&#10;        self.error(message);&#10;    });&#10;	client.open();&#10;};&#10;&#10;exports.purposeInputHandler = function() {&#10;	if (sessionKeyList.length &gt; 0) {&#10;		outputSessionKey(sessionKeyList.shift());&#10;	}&#10;	else {&#10;		// JSON.parse(this.get('purpose'))&#10;		// {group: 'Servers'}&#10;		sendSessionKeyReq(this.getParameter('authHost'), this.getParameter('authPort'),&#10;			2, this.get('purpose'));&#10;	}&#10;};&#10;&#10;exports.initialize = function () {&#10;	authPublicKey = crypto.loadPublicKey(this.getParameter('authCertPath'));&#10;	entityPrivateKey = crypto.loadPrivateKey(this.getParameter('entityPrivateKeyPath'));&#10;	&#10;	entityName = this.getParameter('entityName');&#10;	publicCipherAlgorithm = this.getParameter('publicCipherAlgorithm');&#10;	signAlgorithm = this.getParameter('signAlgorithm');&#10;	distCipherAlgorithm = this.getParameter('distCipherAlgorithm');&#10;	distHashAlgorithm = this.getParameter('distHashAlgorithm');&#10;	&#10;	self = this;&#10;	&#10;	this.addInputHandler('purpose',&#10;		this.exports.purposeInputHandler.bind(this));&#10;};&#10;&#10;/** Close the web socket connection. */&#10;exports.wrapup = function () {&#10;    if (client) {&#10;        client.close();&#10;        console.log('Status: Connection closed in wrapup.');&#10;    }&#10;};&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[385.0, 185.0]">
        </property>
        <property name="authHost" class="ptolemy.data.expr.Parameter" value="localhost">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="authPort" class="ptolemy.data.expr.Parameter" value="21900">
        </property>
        <property name="authCertPath" class="ptolemy.data.expr.Parameter" value="$PROJECT_PATH/entity/auth_certs/Auth101EntityCert.pem">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="entityName" class="ptolemy.data.expr.Parameter" value="net1.ptServer">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="entityPrivateKeyPath" class="ptolemy.data.expr.Parameter" value="$PROJECT_PATH/entity/credentials/keys/net1/PtServerKey.der">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="publicCipherAlgorithm" class="ptolemy.data.expr.Parameter" value="RSA/ECB/PKCS1PADDING">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="signAlgorithm" class="ptolemy.data.expr.Parameter" value="SHA256withRSA">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="distCipherAlgorithm" class="ptolemy.data.expr.Parameter" value="AES-128-CBC">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="distHashAlgorithm" class="ptolemy.data.expr.Parameter" value="SHA-256">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="_flipPortsHorizontal" class="ptolemy.data.expr.Parameter" value="true">
        </property>
        <port name="purpose" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="sessionKey" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
    </entity>
    <relation name="relation6" class="ptolemy.actor.TypedIORelation">
        <property name="width" class="ptolemy.data.expr.Parameter" value="-1">
        </property>
        <vertex name="vertex1" value="[485.0, 250.0]">
        </vertex>
    </relation>
    <relation name="relation8" class="ptolemy.actor.TypedIORelation">
        <property name="width" class="ptolemy.data.expr.Parameter" value="-1">
        </property>
        <vertex name="vertex1" value="{565.0, 250.0}">
        </vertex>
    </relation>
    <relation name="relation9" class="ptolemy.actor.TypedIORelation">
        <vertex name="vertex1" value="[305.0, 185.0]">
        </vertex>
    </relation>
    <relation name="relation" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation3" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation4" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation2" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation5" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation7" class="ptolemy.actor.TypedIORelation">
        <property name="width" class="ptolemy.data.expr.Parameter" value="-1">
        </property>
        <vertex name="vertex1" value="[305.0, 270.0]">
        </vertex>
    </relation>
    <relation name="relation10" class="ptolemy.actor.TypedIORelation">
        <property name="width" class="ptolemy.data.expr.Parameter" value="-1">
        </property>
        <vertex name="vertex1" value="[565.0, 185.0]">
        </vertex>
    </relation>
    <link port="Received.input" relation="relation4"/>
    <link port="Listening.input" relation="relation"/>
    <link port="Connection.input" relation="relation3"/>
    <link port="Error.input" relation="relation2"/>
    <link port="KeyId.input" relation="relation6"/>
    <link port="MicrostepDelay.input" relation="relation10"/>
    <link port="MicrostepDelay.output" relation="relation5"/>
    <link port="SessionKey.input" relation="relation7"/>
    <link port="RecordAssembler.output" relation="relation8"/>
    <link port="RecordAssembler.keyId" relation="relation6"/>
    <link port="SecureIoTServer.error" relation="relation2"/>
    <link port="SecureIoTServer.sessionKey" relation="relation7"/>
    <link port="SecureIoTServer.keyId" relation="relation6"/>
    <link port="SecureIoTServer.listening" relation="relation"/>
    <link port="SecureIoTServer.connection" relation="relation3"/>
    <link port="SecureIoTServer.received" relation="relation4"/>
    <link port="IoTAuthService.purpose" relation="relation5"/>
    <link port="IoTAuthService.sessionKey" relation="relation9"/>
    <link relation1="relation8" relation2="relation10"/>
    <link relation1="relation9" relation2="relation7"/>
</entity>
