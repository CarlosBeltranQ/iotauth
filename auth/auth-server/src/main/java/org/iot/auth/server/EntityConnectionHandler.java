package org.iot.auth.server;

import com.sun.tools.javac.util.Pair;
import org.eclipse.jetty.client.api.ContentResponse;
import org.slf4j.Logger;
import org.iot.auth.AuthServer;
import org.iot.auth.crypto.AuthCrypto;
import org.iot.auth.crypto.SymmetricKeyCryptoSpec;
import org.iot.auth.db.*;
import org.iot.auth.exception.InvalidSessionKeyTargetException;
import org.iot.auth.io.Buffer;
import org.iot.auth.io.BufferedString;
import org.iot.auth.io.VariableLengthInt;
import org.iot.auth.message.*;
import org.iot.auth.util.ExceptionToString;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;

import java.io.IOException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.SignatureException;
import java.sql.SQLException;
import java.util.Date;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeoutException;

/**
 * An abstract handler class for general connections from each entity that requests Auth service (e.g., session key requests)
 * @author Hokeun Kim
 */
public abstract class EntityConnectionHandler {

    protected EntityConnectionHandler(AuthServer server) {
        this.server = server;
    }
    /**
     * Send Auth Hello message to an entity that is connected to Auth, as soon as an entity is connected via TCP/IP
     * @param authNonce Random number generated by Auth, to be sent to the connected entity, to prohibit replay attacks.
     * @throws IOException When socket IO fails.
     */
    protected void sendAuthHello(Buffer authNonce) throws IOException {
        getLogger().info("Sending AUTH_HELLO to entity at Port {} with auth nonce {}",
                getRemoteAddress(), authNonce.toHexString());

        AuthHelloMessage authHello = new AuthHelloMessage(server.getAuthID(), authNonce);

        writeToSocket(authHello.serialize().getRawBytes());
    }

    /**
     * Handle a session key request from the connected entity.
     * @param bytes Raw buffer bytes of the TCP packet received by an entity, to be processed in this method
     * @param authNonce Auth's random number that was sent to the entity, to be checked with the Auth nonce included
     *                  in the session key request.
     * @throws RuntimeException Any security checking fails, including entity's signature and Auth's nonce.
     * @throws IOException If any IO fails.
     * @throws ParseException When JSON parsing fails.
     * @throws SQLException When SQL DB fails.
     * @throws ClassNotFoundException
     */
    protected void handleSessionKeyReq(byte[] bytes, Buffer authNonce) throws RuntimeException, IOException,
            ParseException, SQLException, ClassNotFoundException
    {
        Buffer buf = new Buffer(bytes);
        MessageType type = MessageType.fromByte(buf.getByte(0));

        VariableLengthInt valLenInt = buf.getVariableLengthInt(IoTSPMessage.MSG_TYPE_SIZE);
        // rest of this is payload
        Buffer payload = buf.slice(IoTSPMessage.MSG_TYPE_SIZE + valLenInt.getRawBytes().length);

        if (type == MessageType.SESSION_KEY_REQ_IN_PUB_ENC) {
            getLogger().info("Received session key request message encrypted with public key!");
            // parse signed data
            final int RSA_KEY_SIZE = 256; // 2048 bits
            Buffer encPayload = payload.slice(0, payload.length() - RSA_KEY_SIZE);
            getLogger().debug("Encrypted data ({}): {}", encPayload.length(), encPayload.toHexString());
            Buffer signature = payload.slice(payload.length() - RSA_KEY_SIZE);
            Buffer decPayload = server.getCrypto().authPrivateDecrypt(encPayload);

            getLogger().debug("Decrypted data ({}): {}", decPayload.length(), decPayload.toHexString());
            SessionKeyReqMessage sessionKeyReqMessage = new SessionKeyReqMessage(type, decPayload);

            RegisteredEntity requestingEntity = server.getRegisteredEntity(sessionKeyReqMessage.getEntityName());

            // checking signature
            try {
                if (!server.getCrypto().verifySignedData(encPayload, signature, requestingEntity.getPublicKey())) {
                    throw new RuntimeException("Entity signature verification failed!!");
                }
                else {
                    getLogger().debug("Entity signature is correct!");
                }
            }
            catch (NoSuchAlgorithmException | InvalidKeyException | SignatureException e) {
                throw new RuntimeException("Entity signature verification failed!!");
            }

            Pair<List<SessionKey>, SymmetricKeyCryptoSpec> ret;
            try {
                ret = processSessionKeyReq(requestingEntity, sessionKeyReqMessage, authNonce);
            }
            catch (InvalidSessionKeyTargetException e) {
                getLogger().info("InvalidSessionKeyTargetException: " + e.getMessage());
                sendAuthAlert(AuthAlertCode.INVALID_SESSION_KEY_REQ_TARGET);
                close();
                return;
            }
            List<SessionKey> sessionKeyList = ret.fst;
            SymmetricKeyCryptoSpec sessionCryptoSpec = ret.snd;

            // generate distribution key
            // Assuming AES-CBC-128
            DistributionKey distributionKey =
                    new DistributionKey(AuthCrypto.generateSymmetricKey(requestingEntity.getDistCryptoSpec().getCipherKeySize()),
                            new Date().getTime() + requestingEntity.getDisKeyValidity());
            // update distribution key
            server.updateDistributionKey(requestingEntity.getName(), distributionKey);

            Buffer encryptedDistKey = server.getCrypto().authPublicEncrypt(distributionKey.serialize(),
                    requestingEntity.getPublicKey());
            encryptedDistKey.concat(server.getCrypto().signWithPrivateKey(encryptedDistKey));

            sendSessionKeyResp(distributionKey, requestingEntity.getDistCryptoSpec(), sessionKeyReqMessage.getEntityNonce(),
                    sessionKeyList, sessionCryptoSpec, encryptedDistKey);
            close();
        }
        else if (type == MessageType.SESSION_KEY_REQ) {
            getLogger().info("Received session key request message encrypted with distribution key!");
            BufferedString bufferedString = payload.getBufferedString(0);
            String requestingEntityName = bufferedString.getString();
            RegisteredEntity requestingEntity = server.getRegisteredEntity(requestingEntityName);

            // TODO: check distribution key validity here and if not, refuse request
            if (requestingEntity.getDistributionKey() == null) {
                getLogger().error("No distribution key is available!");
                sendAuthAlert(AuthAlertCode.INVALID_DISTRIBUTION_KEY);
                close();
                return;
            }
            else if (new Date().getTime() > requestingEntity.getDistributionKey().getExpirationTime().getTime()) {
                getLogger().error("Distribution key is expired!");
                sendAuthAlert(AuthAlertCode.INVALID_DISTRIBUTION_KEY);
                close();
                return;
            }

            Buffer encPayload = payload.slice(bufferedString.length());

            Buffer decPayload = AuthCrypto.symmetricDecryptAuthenticate(encPayload,
                    requestingEntity.getDistributionKey().getKeyVal(), requestingEntity.getDistCryptoSpec());

            SessionKeyReqMessage sessionKeyReqMessage = new SessionKeyReqMessage(type, decPayload);

            Pair<List<SessionKey>, SymmetricKeyCryptoSpec> ret;
            try {
                ret = processSessionKeyReq(requestingEntity, sessionKeyReqMessage, authNonce);
            } catch (InvalidSessionKeyTargetException e) {
                getLogger().info("InvalidSessionKeyTargetException: " + e.getMessage());
                sendAuthAlert(AuthAlertCode.INVALID_SESSION_KEY_REQ_TARGET);
                close();
                return;
            }
            List<SessionKey> sessionKeyList = ret.fst;
            SymmetricKeyCryptoSpec sessionCryptoSpec = ret.snd;

            sendSessionKeyResp(requestingEntity.getDistributionKey(), requestingEntity.getDistCryptoSpec(), sessionKeyReqMessage.getEntityNonce(),
                    sessionKeyList, sessionCryptoSpec, null);
            close();
        }
        else {
            getLogger().info("Received unrecognized message from the entity!");
            close();
        }
    }

    /**
     * Send an alert message to the connected entity, when security problem arises.
     * @param authAlertCode Code for the alert, indicating what kind of problem happened.
     * @throws IOException If socket IO fails.
     */
    protected void sendAuthAlert(AuthAlertCode authAlertCode) throws IOException {
        writeToSocket(new AuthAlertMessage(authAlertCode).serialize().getRawBytes());
    }

    /**
     * Send a session key response to the requesting entity
     * @param distributionKey Distribution key used for sending session key response
     * @param distCryptoSpec Cryptography specification for session key distribution
     * @param entityNonce Random number generated by the requesting entity, to be included in the response
     * @param sessionKeyList A list of session keys to be included in the response
     * @param sessionCryptoSpec Cryptography specification for the session keys in the response
     * @param encryptedDistKey Can be null. If not null, it is the distribution key encrypted using public key
     *                         cryptography. If null, it means the session key request was encrypted with a distribution
     *                         key that is shared a priory, so no need to include it.
     * @throws IOException If TCP socket IO fails.
     */
    protected void sendSessionKeyResp(DistributionKey distributionKey, SymmetricKeyCryptoSpec distCryptoSpec, Buffer entityNonce,
                                    List<SessionKey> sessionKeyList, SymmetricKeyCryptoSpec sessionCryptoSpec,
                                    Buffer encryptedDistKey) throws IOException
    {
        SessionKeyRespMessage sessionKeyResp;
        if (encryptedDistKey != null) {
            sessionKeyResp = new SessionKeyRespMessage(encryptedDistKey, entityNonce, sessionCryptoSpec, sessionKeyList);
        }
        else {
            sessionKeyResp = new SessionKeyRespMessage(entityNonce, sessionCryptoSpec, sessionKeyList);
        }
        writeToSocket(sessionKeyResp.serializeAndEncrypt(distributionKey, distCryptoSpec).getRawBytes());
    }

    /**
     * Interpret a session key request from the entity, and process it. The process includes communication policy
     * checking, session key generation, and communicating with a trusted Auth to get the session key.
     * @param requestingEntity The entity who sent the session key request.
     * @param sessionKeyReqMessage The session key request message object.
     * @param authNonce Auth nonce to be checked with the nonce in the session key request message.
     * @return A pair of resulting session key list and usage (cryptography) specification for the session keys. The
     * session keys can be either generated or retrieved from a trusted Auth.
     * @throws IOException
     * @throws ParseException
     * @throws SQLException
     * @throws ClassNotFoundException
     */
    protected Pair<List<SessionKey>, SymmetricKeyCryptoSpec> processSessionKeyReq(
            RegisteredEntity requestingEntity, SessionKeyReqMessage sessionKeyReqMessage, Buffer authNonce)
            throws IOException, ParseException, SQLException, ClassNotFoundException, InvalidSessionKeyTargetException
    {
        getLogger().debug("Sender entity: {}", sessionKeyReqMessage.getEntityName());

        getLogger().debug("Received auth nonce: {}", sessionKeyReqMessage.getAuthNonce().toHexString());
        if (!authNonce.equals(sessionKeyReqMessage.getAuthNonce())) {
            throw new RuntimeException("Auth nonce does not match!");
        }
        else {
            getLogger().debug("Auth nonce is correct!");
        }

        JSONObject purpose = sessionKeyReqMessage.getPurpose();
        SessionKeyReqPurpose reqPurpose = new SessionKeyReqPurpose(purpose);

        SymmetricKeyCryptoSpec cryptoSpec = null;
        List<SessionKey> sessionKeyList = null;
        switch (reqPurpose.getTargetType()) {
            case TARGET_GROUP:
            case PUBLISH_TOPIC: {
                CommunicationPolicy communicationPolicy = server.getCommunicationPolicy(requestingEntity.getGroup(),
                        reqPurpose.getTargetType(), (String)reqPurpose.getTarget());
                if (communicationPolicy == null) {
                    throw new InvalidSessionKeyTargetException("Unrecognized Purpose: "
                            + purpose.toString());
                }
                cryptoSpec = communicationPolicy.getSessionCryptoSpec();
                // generate session keys
                SessionKeyPurpose sessionKeyPurpose =
                        new SessionKeyPurpose(reqPurpose.getTargetType(), (String)reqPurpose.getTarget());
                getLogger().debug("numKeys {}", sessionKeyReqMessage.getNumKeys());
                sessionKeyList = server.generateSessionKeys(requestingEntity.getName(),
                        sessionKeyReqMessage.getNumKeys(), communicationPolicy, sessionKeyPurpose);
                break;
            }
            case SUBSCRIBE_TOPIC: {
                CommunicationPolicy communicationPolicy = server.getCommunicationPolicy(requestingEntity.getGroup(),
                        reqPurpose.getTargetType(), (String)reqPurpose.getTarget());
                if (communicationPolicy == null) {
                    throw new InvalidSessionKeyTargetException("Unrecognized Purpose: "
                            + purpose.toString());
                }
                cryptoSpec = communicationPolicy.getSessionCryptoSpec();
                SessionKeyPurpose sessionKeyPurpose =
                        new SessionKeyPurpose(reqPurpose.getTargetType(), (String)reqPurpose.getTarget());
                sessionKeyList = server.getSessionKeysByPurpose(requestingEntity.getName(), sessionKeyPurpose);
                for (SessionKey sessionKey : sessionKeyList) {
                    server.addSessionKeyOwner(sessionKey.getID(), requestingEntity.getName());
                }
                break;
            }
            case SESSION_KEY_ID: {
                Object objTarget = reqPurpose.getTarget();
                SessionKey sessionKey = null;
                getLogger().debug("objTarget class: {}", objTarget.getClass());
                long sessionKeyID = -1;
                if (objTarget.getClass() == Integer.class) {
                    sessionKeyID = (long)(Integer)objTarget;
                }
                else if (objTarget.getClass() == Long.class) {
                    sessionKeyID = (Long)objTarget;
                }
                else {
                    throw new RuntimeException("Wrong class for session key ID!");
                }
                int authID = AuthDB.decodeAuthIDFromSessionKeyID(sessionKeyID);
                getLogger().info("ID of Auth that generated this key: {}", authID);

                if (authID == server.getAuthID()) {
                    getLogger().info("This session key was generated by me");
                    sessionKey = server.getSessionKeyByID(sessionKeyID);

                    sessionKeyList = new LinkedList<SessionKey>();
                    sessionKeyList.add(sessionKey);
                    cryptoSpec = sessionKey.getCryptoSpec();
                    server.addSessionKeyOwner(sessionKeyID, requestingEntity.getName());
                }
                else {
                    // TODO: if authID is not my ID, then send request via HTTPS
                    getLogger().info("This session key was generated by someone else");
                    return sendAuthSessionKeyReq(requestingEntity, authID, sessionKeyID);
                }

                break;
            }
            default: {
                getLogger().error("Unrecognized target for session key request!");
                break;
            }
        }

        return new Pair<>(sessionKeyList, cryptoSpec);
    }

    /**
     * Send an Auth session key request to a trusted Auth, on behalf of the requesting entity.
     * @param requestingEntity The entity who initiated the session key request.
     * @param trustedAuthID Identifier of the trusted Auth to which this method sends the request.
     * @param sessionKeyID Session key's identifier specified in the original session key request by an entity.
     * @return A pair of the session key list and usage specification of the session keys
     * @throws IOException If IO fails.
     * @throws ParseException If JSON parsing fails.
     */
    protected Pair<List<SessionKey>, SymmetricKeyCryptoSpec> sendAuthSessionKeyReq(
            RegisteredEntity requestingEntity, int trustedAuthID, long sessionKeyID) throws IOException, ParseException
    {
        getLogger().info("Sending auth session key req to Auth {}", trustedAuthID);
        TrustedAuth trustedAuth = server.getTrustedAuthInfo(trustedAuthID);

        ContentResponse res;
        try {
            AuthSessionKeyReqMessage authSessionKeyReqMessage = new AuthSessionKeyReqMessage(sessionKeyID,
                    requestingEntity.getName(), requestingEntity.getGroup());
            res = server.performPostRequest(
                    "https://" + trustedAuth.getHost() + ":" + trustedAuth.getPort(),
                    authSessionKeyReqMessage.toJSONObject());
        } catch (InterruptedException | ExecutionException | TimeoutException e) {
            getLogger().error("Exception {}", ExceptionToString.convertExceptionToStackTrace(e));
            throw new RuntimeException();
        }

        getLogger().info("Received contents via https {}", res.getContentAsString());

        AuthSessionKeyRespMessage authSessionKeyRespMessage = AuthSessionKeyRespMessage.fromJSONObject(
                (JSONObject) new JSONParser().parse(res.getContentAsString()));

        getLogger().info("Received AuthSessionKeyRespMessage: {}", authSessionKeyRespMessage.toString());
        List<SessionKey> sessionKeyList = new LinkedList<SessionKey>();
        SessionKey sessionKey = authSessionKeyRespMessage.getSessionKey();
        sessionKeyList.add(sessionKey);
        return new Pair<>(sessionKeyList, sessionKey.getCryptoSpec());
    }

    abstract protected Logger getLogger();
    abstract protected void writeToSocket(byte[] bytes) throws IOException;
    abstract protected void close();
    abstract protected String getRemoteAddress();
    private AuthServer server;
}
