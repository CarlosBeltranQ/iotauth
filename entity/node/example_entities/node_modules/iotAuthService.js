/*
 * Copyright (c) 2016, Regents of the University of California
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * IOTAUTH_COPYRIGHT_VERSION_1
 */

/**
 * Helper module for accessing IoT Auth services, including session key request and responses
 * @author Hokeun Kim
 */

"use strict";

var net = require('net');
var dgram = require('dgram');
var crypto = require('crypto');
var util = require('util');

// local modules
var common = require('./common');
var msgType = common.msgType;

// local variables
var AUTH_NONCE_SIZE = 8;        // auth nonce size
var DIST_KEY_EXPIRATION_TIME_SIZE = 6;
var SESSION_KEY_EXPIRATION_TIME_SIZE = 6;
var REL_VALIDITY_SIZE = 6;

// generate auth hello nonce
var generateAuthNonce = function() {
    return crypto.randomBytes(AUTH_NONCE_SIZE);
};

/*
    AuthHello Format
    {
        authId: /UInt32BE/,    // identifier of auth (when auths are replicated)
        nonce: /Buffer/
    }
*/
var serializeAuthHello = function(obj) {
    if (obj.authId == undefined || obj.nonce == undefined) {
        console.log('Error: AuthHello authId or nonce is missing.');
        return;
    }
    var buf = new Buffer(4 + AUTH_NONCE_SIZE);
    buf.writeUInt32BE(obj.authId, 0);
    obj.nonce.copy(buf, 4);
    return buf;
};
var parseAuthHello = function(buf) {
    var authId = buf.readUInt32BE(0);
    var nonce = buf.slice(4, 4 + AUTH_NONCE_SIZE);
    return {authId: authId, nonce: nonce};
};

/*
    SessionKeyReq Format
    {
        nonce: /Buffer/, (AUTH_NONCE_SIZE)
        replyNonce:    /Buffer/, (AUTH_NONCE_SIZE)
        numKeys: /UInt32BE/,
        sender: /string/, (senderLen UInt8)
        purpose: JSON,
        dhParam: /Buffer/ (optional, Diffie-Hellman parameter)
    }
*/
var serializeSessionKeyReq = function(obj) {
    if (obj.nonce == undefined || obj.replyNonce == undefined || obj.sender == undefined
        || obj.purpose == undefined || obj.numKeys == undefined) {
        console.log('Error: SessionKeyReq nonce or replyNonce '
            + 'or purpose or numKeys is missing.');
        return;
    }
    var buf = new Buffer(AUTH_NONCE_SIZE * 2 + 4);
    obj.nonce.copy(buf, 0);
    obj.replyNonce.copy(buf, AUTH_NONCE_SIZE);
    buf.writeUInt32BE(obj.numKeys, AUTH_NONCE_SIZE * 2);

    var senderBuf = common.serializeStringParam(obj.sender);
    var purposeBuf = common.serializeStringParam(JSON.stringify(obj.purpose));

    var ret = Buffer.concat([buf, senderBuf, purposeBuf]);
    if (obj.dhParam) {
        ret = Buffer.concat([ret, obj.dhParam]);
    }
    return ret;
};

/*
    DistributionKey Format
    {
        absValidity: /UIntBE, DIST_KEY_EXPIRATION_TIME_SIZE Bytes, Date() format/, // for absolute validity period
        cipherKeySize: /UInt8BE/,
        cipherKeyVal: /Buffer/,
        macKeySize: /UInt8BE/,
        macKeyVal: /Buffer/
    }
*/
var parseDistributionKey = function(buf) {
    var absValidity = new Date(buf.readUIntBE(0, DIST_KEY_EXPIRATION_TIME_SIZE));
    var curIndex = DIST_KEY_EXPIRATION_TIME_SIZE;
    var cipherKeySize = buf.readUInt8(curIndex);
    curIndex += 1;
    var cipherKeyVal = buf.slice(curIndex, curIndex + cipherKeySize);
    curIndex += cipherKeySize;
    var macKeySize = buf.readUInt8(curIndex);
    curIndex += 1;
    var macKeyVal = buf.slice(curIndex, curIndex + macKeySize);
    return {
        cipherKeyVal: cipherKeyVal,
        macKeyVal: macKeyVal,
        absValidity: absValidity
    };
};

/*
    DistributionDiffieHellmanParameter Format
    {
        absValidity: /UIntBE, DIST_KEY_EXPIRATION_TIME_SIZE Bytes, Date() format/, // for absolute validity period
        parameterLength: /VarLenInt/
        parameter: /Buffer/
    }
*/
var parseDistributionDiffieHellmanParameter = function(buf) {
    var curIndex = 0;
    var absValidity = new Date(buf.readUIntBE(curIndex, DIST_KEY_EXPIRATION_TIME_SIZE));
    curIndex += DIST_KEY_EXPIRATION_TIME_SIZE;
    var ret = common.varLenIntToNum(buf, curIndex);
    curIndex += ret.bufLen;
    return {
        absValidity: absValidity,
        parameter: buf.slice(curIndex)
    }
}
/*
    SessionKey Format
    {
        id: /UIntBE, SESSION_KEY_ID_SIZE Bytes/,
        absValidity: /UIntBE, SESSION_KEY_EXPIRATION_TIME_SIZE Bytes, Date() format/, // for absolute validity period
        relValidity: /UIntBE, REL_VALIDITY_SIZE Bytes, integer in millisecons/, // for relative validity period
        val: /Buffer/
    }
*/
function parseSessionKey(buf) {
    var keyId = buf.readUIntBE(0, common.SESSION_KEY_ID_SIZE);
    var curIndex = common.SESSION_KEY_ID_SIZE;

    var absValidity = new Date(buf.readUIntBE(curIndex, SESSION_KEY_EXPIRATION_TIME_SIZE));
    curIndex += SESSION_KEY_EXPIRATION_TIME_SIZE;
    var relValidity = buf.readUIntBE(curIndex, REL_VALIDITY_SIZE);
    curIndex += REL_VALIDITY_SIZE;

    var cipherKeySize = buf.readUInt8(curIndex);
    curIndex += 1;
    var cipherKeyVal = buf.slice(curIndex, curIndex + cipherKeySize);
    curIndex += cipherKeySize;
    var macKeySize = buf.readUInt8(curIndex);
    curIndex += 1;
    var macKeyVal = buf.slice(curIndex, curIndex + macKeySize);
    curIndex += macKeySize;

    var sessionKey = {
        id: keyId,
        cipherKeyVal: cipherKeyVal,
        macKeyVal: macKeyVal,
        absValidity: absValidity,
        relValidity: relValidity
    };
    return {sessionKey: sessionKey, totalLen: curIndex};
};

/*
    SessionKeyReq (encrypted with Distribution Key) Format
    {
        sender: /string/, (senderLen UInt8) should be plain text so that Auth can find distribution key
        enBuf: /Buffer/ SessionKeyReq (nonce included) encrypted with distribution key
    }
*/
var serializeSessionKeyReqWithDistributionKey = function(senderName,
    sessionKeyReq, distributionKey, distributionCryptoSpec) {
    var sessionKeyReqBuf = serializeSessionKeyReq(sessionKeyReq);
    var encBuf = common.symmetricEncryptAuthenticate(sessionKeyReqBuf, distributionKey, distributionCryptoSpec);

    // TEST: generating error in encrypted data
    //encBuf.writeUInt8(12, encBuf.length - 12);

    var senderBuf = new Buffer(senderName);
    var lengthBuf = new Buffer(1);
    lengthBuf.writeUInt8(senderBuf.length);
    return Buffer.concat([lengthBuf, senderBuf, encBuf]);
};

/*
    SessionKeyResp Format
    {
        replyNonce:    /Buffer/,
        cryptoSpec:    /JSON/ {cipher: 'AES-128-CBC', hash: 'SHA256'} stringified, 
        sessionKeyList: /UInt32BE for length and List of SessionKey's/
        // TODO: who you're talking to? if req included keyId=?
    }
*/
var parseSessionKeyResp = function(buf) {
    var replyNonce = buf.slice(0, AUTH_NONCE_SIZE);
    var bufIdx = AUTH_NONCE_SIZE;

    var ret = common.parseStringParam(buf, bufIdx);
    var cryptoSpec = JSON.parse(ret.str);
    bufIdx += ret.len;

    var sessionKeyListLength = buf.readUInt32BE(bufIdx);
    bufIdx += 4;

    var sessionKeyList = [];
    for (var i = 0; i < sessionKeyListLength; i++) {
        var ret = parseSessionKey(buf.slice(bufIdx));
        var sessionKey = ret.sessionKey;
        sessionKeyList.push(sessionKey);
        bufIdx += ret.totalLen;
    }
    return {replyNonce: replyNonce, cryptoSpec: cryptoSpec, sessionKeyList: sessionKeyList};
};

///////////////////////////////////////////////////////////////////
////           Functions for accessing Auth service            ////

/*
helperOptions = {
    msgType,
    payload,
    myNonce,
    myECDH // object for ECDH: Elliptic Curve Diffie-Hellman (optionally created inside sendSessionKeyReqHelper)
}
*/
/*
helperEventHandlers = {
    onWrite,
    onEnd
}
*/
/*
ret = {
    success,
    myNonce,
    myECDH
}
*/
function sendSessionKeyReqHelper(helperOptions, helperEventHandlers,
    options, sessionKeyRespHandler, callbackParams) {
    if (helperOptions.msgType == msgType.AUTH_HELLO) {
        console.log('received auth hello!');
        var obj = parseAuthHello(helperOptions.payload);
        console.log(obj);
        helperOptions.myNonce = generateAuthNonce();

        var sessionKeyReq = {
            nonce: helperOptions.myNonce,
            replyNonce: obj.nonce,
            numKeys: options.numKeysPerRequest,
            sender: options.entityName,
            purpose: options.purpose
        };

        var msg;
        if (options.distributionKey == null || options.distributionKey.absValidity < new Date()) {
            if (options.distributionKey != null) {
                console.log('current distribution key expired, '
                    + 'requesting new distribution key as well...');
            }
            if (options.publicKeyCryptoSpec.diffieHellman) {
                console.log('Diffie-Hellman enabled for distribution key, creating DH parameters...');
                helperOptions.myECDH = crypto.createECDH(options.publicKeyCryptoSpec.diffieHellman);
                sessionKeyReq.dhParam = helperOptions.myECDH.generateKeys();
            }
            var sessionKeyReqBuf = serializeSessionKeyReq(sessionKeyReq);
            msg = {
                msgType: msgType.SESSION_KEY_REQ_IN_PUB_ENC,
                payload: common.publicEncryptAndSign(
                    sessionKeyReqBuf, options.authPublicKey, options.entityPrivateKey, options.publicKeyCryptoSpec)
            };
            // TEST: generating error in signature
            //msg.payload.writeUInt8(12, msg.payload.length - 12);
        }
        else {
            msg = {
                msgType: msgType.SESSION_KEY_REQ,
                payload: serializeSessionKeyReqWithDistributionKey(options.entityName,
                    sessionKeyReq, options.distributionKey, options.distributionCryptoSpec)
            };
        }
        
        var buf = common.serializeIoTSP(msg);
        helperEventHandlers.onWrite(buf);
    }
    else if (helperOptions.msgType == msgType.SESSION_KEY_RESP_WITH_DIST_KEY) {
        console.log('received session key response with distribution key attached!');

        var distributionKeyBuf = helperOptions.payload.slice(0, common.getPublicEncryptedAndSignedMessageSize(options.publicKeyCryptoSpec));
        var sessionKeyBuf = helperOptions.payload.slice(common.getPublicEncryptedAndSignedMessageSize(options.publicKeyCryptoSpec));

        var ret = common.verifySignedData(distributionKeyBuf, options.authPublicKey, options.publicKeyCryptoSpec);
        if (!ret.verified) {
            return {success: false, error: 'auth signature NOT verified'};
        }
        console.log('auth signature verified');
        var decBuf = common.privateDecrypt(ret.buf, options.entityPrivateKey, options.publicKeyCryptoSpec);

        var receivedOrDerivedDistKey;
        if (options.publicKeyCryptoSpec.diffieHellman) {
            console.log('Diffie-Hellman enabled! Getting DH parameter from Auth...');
            // if so, receivedDistKey.cipherKeyVal should be a Diffie-Hellman parameter rather than a distribution key
            var authDHParam = parseDistributionDiffieHellmanParameter(decBuf);
            var dhSecret = helperOptions.myECDH.computeSecret(authDHParam.parameter);
            var cipherKeySize = common.getCryptoKeySize(options.distributionCryptoSpec.cipher);
            var macKeySize = common.getCryptoKeySize(options.distributionCryptoSpec.mac);
            receivedOrDerivedDistKey = {
                absValidity: authDHParam.absValidity,
                cipherKeyVal: dhSecret.slice(0, cipherKeySize),
                macKeyVal: dhSecret.slice(cipherKeySize, cipherKeySize + macKeySize)
            }
            console.log('New ephemeral distribution key successfully generated from DH parameter of Auth!');
        }
        else {
            receivedOrDerivedDistKey = parseDistributionKey(decBuf);
        }

        decBuf = common.symmetricDecryptAuthenticate(sessionKeyBuf, receivedOrDerivedDistKey, options.distributionCryptoSpec);

        var sessionKeyResp = parseSessionKeyResp(decBuf);
        console.log('replyNonce in sessionKeyResp: ' + util.inspect(sessionKeyResp.replyNonce));
        if (!helperOptions.myNonce.equals(sessionKeyResp.replyNonce)) {
            return {success: false, error: 'auth nonce NOT verified'};
        }
        console.log('auth nonce verified');

        sessionKeyRespHandler(sessionKeyResp.sessionKeyList, receivedOrDerivedDistKey, callbackParams);
        helperEventHandlers.onEnd();
    }
    else if (helperOptions.msgType == msgType.SESSION_KEY_RESP) {
        console.log('received session key response encrypted with distribution key');

        var decBuf = common.symmetricDecryptAuthenticate(helperOptions.payload, options.distributionKey, options.distributionCryptoSpec);

        var sessionKeyResp = parseSessionKeyResp(decBuf);
        console.log('replyNonce in sessionKeyResp: ' + util.inspect(sessionKeyResp.replyNonce));
        if (!helperOptions.myNonce.equals(sessionKeyResp.replyNonce)) {
            return {success: false, error: 'auth nonce NOT verified'};
        }
        console.log('auth nonce verified');

        sessionKeyRespHandler(sessionKeyResp.sessionKeyList, null, callbackParams);
        helperEventHandlers.onEnd();
    }
    return {success: true, myNonce: helperOptions.myNonce, myECDH: helperOptions.myECDH};
};

exports.sendSessionKeyReqViaTCP = function(options, sessionKeyRespHandler, callbackParams) {
    var myNonce;
    var myECDH;
    var expectingMoreData = false;
    var obj;
    var authClientSocket = net.connect({host: options.authHost,port: options.authPort}, 
        function() {
            console.log('connected to auth! from local port ' + authClientSocket.localPort);
    });
    function onEnd() {
        authClientSocket.end();
    }
    function onWrite(buf) {
        authClientSocket.write(buf);
    }
    var helperEventHandlers = {
        onEnd: onEnd,
        onWrite: onWrite
    };
    authClientSocket.on('data', function(data) {
        if (!expectingMoreData) {
            obj = common.parseIoTSP(data);
            if (obj.payload.length < obj.payloadLen) {
                expectingMoreData = true;
                console.log('more data will come. current: ' + obj.payload.length
                    + ' expected: ' + obj.payloadLen);
            }
        }
        else {
            obj.payload = Buffer.concat([obj.payload, data]);
            if (obj.payload.length ==  obj.payloadLen) {
                expectingMoreData = false;
            }
            else {
                console.log('more data will come. current: ' + obj.payload.length
                    + ' expected: ' + obj.payloadLen);
            }
        }

        // Test code
        //sleep.sleep(1);

        if (expectingMoreData) {
            // do not process the packet yet
            return;
        }
        else {
            var helperOptions = {
                msgType: obj.msgType,
                payload: obj.payload,
                myNonce: myNonce,
                myECDH: myECDH
            };
            var ret = sendSessionKeyReqHelper(helperOptions, helperEventHandlers,
                options, sessionKeyRespHandler, callbackParams);
            if (!ret.success) {
                console.error(ret.error);
                authClientSocket.end();
                return;
            }
            myNonce = ret.myNonce;
            myECDH = ret.myECDH;
        }
    });
    authClientSocket.on('end', function() {
        console.log('disconnected from auth');
    });
};

exports.sendSessionKeyReqViaUDP = function(options, sessionKeyRespHandler, callbackParams) {
    var authUdpClientSocket = dgram.createSocket('udp4');

    function onEnd() {
        authUdpClientSocket.close();
    }
    function onWrite(buf) {
        authUdpClientSocket.send(buf, 0, buf.length, options.authPort, options.authHost, (err) => {
            //socket.close();
        });
    }
    var helperEventHandlers = {
        onEnd: onEnd,
        onWrite: onWrite
    };

    authUdpClientSocket.on('listening', () => {
      var address = authUdpClientSocket.address();
      console.log('entity listening to Auth on ' + address.address + ':' + address.port);
    });

    var myNonce;
    var myECDH;
    authUdpClientSocket.on('message', (data, rinfo) => {
        // if it's auth hello?

        console.log('some message received?');
        console.log('Received %d bytes from %s:%d\n',
            data.length, rinfo.address, rinfo.port);

        var obj = common.parseIoTSP(data);
        if (obj.payload.length != obj.payloadLen) {
            console.error('wrong payload length: ' + obj.payload.length + ' should be: ' + obj.payloadLen);
            return;
        }

        var helperOptions = {
            msgType: obj.msgType,
            payload: obj.payload,
            myNonce: myNonce,
            myECDH: myECDH
        };
        var ret = sendSessionKeyReqHelper(helperOptions, helperEventHandlers,
            options, sessionKeyRespHandler, callbackParams);
        if (!ret.success) {
            console.error(ret.error);
            authUdpClientSocket.end();
            return;
        }
        myNonce = ret.myNonce;
        myECDH = ret.myECDH;
    });

    authUdpClientSocket.bind();

    var entityHello = new Buffer(1);
    entityHello.writeUInt8(msgType.ENTITY_HELLO);

    authUdpClientSocket.send(entityHello, 0, entityHello.length, options.authPort, options.authHost, (err) => {
        //socket.close();
    });
};
