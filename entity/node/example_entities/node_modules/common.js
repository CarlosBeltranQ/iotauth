/*
 * Copyright (c) 2016, Regents of the University of California
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * IOTAUTH_COPYRIGHT_VERSION_1
 */

/**
 * Global common file for example entities.
 * @author Hokeun Kim
 */

"use strict";

var crypto = require('crypto');
var net = require('net');
var constants = require('constants');

// global variables
exports.SESSION_KEY_ID_SIZE = 8;

exports.msgType = {
    AUTH_HELLO: 0,
    ENTITY_HELLO: 1,
    AUTH_SESSION_KEY_REQ: 10,
    AUTH_SESSION_KEY_RESP: 11,
    SESSION_KEY_REQ_IN_PUB_ENC: 20,
    SESSION_KEY_RESP_WITH_DIST_KEY: 21,    // Includes distribution message (session keys)
    SESSION_KEY_REQ: 22,        // Distribution message
    SESSION_KEY_RESP: 23,        // Distribution message
    SKEY_HANDSHAKE_1: 30,
    SKEY_HANDSHAKE_2: 31,
    SKEY_HANDSHAKE_3: 32,
    SECURE_COMM_MSG: 33,
    FIN_SECURE_COMM: 34,
    SECURE_PUB: 40,
    AUTH_ALERT: 100
};

// local variables

var AUTH_NONCE_SIZE = 8;        // auth nonce size

var DIST_KEY_EXPIRATION_TIME_SIZE = 6;
var SESSION_KEY_EXPIRATION_TIME_SIZE = 6;
var REL_VALIDITY_SIZE = 6;

// generate auth hello nonce
exports.generateAuthNonce = function() {
    return crypto.randomBytes(AUTH_NONCE_SIZE);
};

/*
    AuthHello Format
    {
        authId: /UInt32BE/,    // identifier of auth (when auths are replicated)
        nonce: /Buffer/
    }
*/
exports.serializeAuthHello = function(obj) {
    if (obj.authId == undefined || obj.nonce == undefined) {
        console.log('Error: AuthHello authId or nonce is missing.');
        return;
    }
    var buf = new Buffer(4 + AUTH_NONCE_SIZE);
    buf.writeUInt32BE(obj.authId, 0);
    obj.nonce.copy(buf, 4);
    return buf;
};
exports.parseAuthHello = function(buf) {
    var authId = buf.readUInt32BE(0);
    var nonce = buf.slice(4, 4 + AUTH_NONCE_SIZE);
    return {authId: authId, nonce: nonce};
};

function getCipherIvSize(cipherAlgorithm) {
    if (cipherAlgorithm.toUpperCase().startsWith('AES')) {
        return 16;
    }
    else if (cipherAlgorithm.toUpperCase().startsWith('DES')) {
        return 8;
    }
    else {
        console.log('Error: cipher NOT supported');
        return -1;
    }
};

function getMacSize(macAlgorithm) {
    if (!macAlgorithm) {
        // No MAC algorithm defined (e.g. AES-128-GCM)
        return 0;
    }
    else if (macAlgorithm.toUpperCase() === 'SHA256') {
        return 32;
    }
    else if (macAlgorithm.toUpperCase() === 'SHA1') {
        return 20;
    }
};

exports.symmetricEncryptAuthenticate = function(buf, symmetricKeySet, symmetricCryptoSpec)
{
    var iv = new Buffer(crypto.randomBytes(getCipherIvSize(symmetricCryptoSpec.cipher)));
    var cipher = crypto.createCipheriv(symmetricCryptoSpec.cipher, symmetricKeySet.cipherKeyVal, iv);
    var enc = cipher.update(buf);
    enc = Buffer.concat([iv, enc, cipher.final()]);

    var hmac = crypto.createHmac(symmetricCryptoSpec.mac, symmetricKeySet.macKeyVal);
    hmac.update(enc);
    var tag = hmac.digest();
    // TEST: generating error in encrypted data
    //tag.writeUInt8(4, tag.length - 4);
    return Buffer.concat([enc, tag]);
};

// returns {hashOk: bool, data: Buffer}
exports.symmetricDecryptAuthenticate = function(buf, symmetricKeySet, symmetricCryptoSpec)
{
    var macSize = getMacSize(symmetricCryptoSpec.mac);
    var enc = buf.slice(0, buf.length - macSize);
    var receivedTag = buf.slice(buf.length - macSize);
    var hmac = crypto.createHmac(symmetricCryptoSpec.mac, symmetricKeySet.macKeyVal);
    hmac.update(enc);
    var computedTag = hmac.digest();
    if (!computedTag.equals(receivedTag)) {
        throw 'Invalid MAC error!';
    }

    var ivSize = getCipherIvSize(symmetricCryptoSpec.cipher);
    var iv = enc.slice(0, ivSize);
    var decipher = crypto.createDecipheriv(symmetricCryptoSpec.cipher, symmetricKeySet.cipherKeyVal, iv);
    var dec = decipher.update(enc.slice(ivSize));
    return Buffer.concat([dec, decipher.final()]);
};

function serializeStringParam(stringParam) {
    var result;
    if (stringParam == null) {
        result = numToVarLenInt(0);
    }
    else {
        var strLenBuf = numToVarLenInt(stringParam.length);
        var strBuf = new Buffer(stringParam.length);
        strBuf.write(stringParam, 0);
        result = Buffer.concat([strLenBuf, strBuf]);
    }
    return result;
};

function parseStringParam(buf, offset) {
    var ret = varLenIntToNum(buf, offset);
    if (ret.bufLen == 0) {
        return {len: 1, str: null};
    }
    var strLen = ret.num;
    var str = buf.toString('utf8', offset + ret.bufLen, offset + ret.bufLen + strLen);
    return {len: ret.bufLen + strLen, str: str};
};

/*
    SessionKeyReq Format
    {
        nonce: /Buffer/, (AUTH_NONCE_SIZE)
        replyNonce:    /Buffer/, (AUTH_NONCE_SIZE)
        numKeys: /UInt32BE/,
        sender: /string/, (senderLen UInt8)
        purpose: JSON
    }
*/
exports.serializeSessionKeyReq = function(obj) {
    if (obj.nonce == undefined || obj.replyNonce == undefined || obj.sender == undefined
        || obj.purpose == undefined || obj.numKeys == undefined) {
        console.log('Error: SessionKeyReq nonce or replyNonce '
            + 'or purpose or numKeys is missing.');
        return;
    }
    var buf = new Buffer(AUTH_NONCE_SIZE * 2 + 4);
    obj.nonce.copy(buf, 0);
    obj.replyNonce.copy(buf, AUTH_NONCE_SIZE);
    buf.writeUInt32BE(obj.numKeys, AUTH_NONCE_SIZE * 2);

    var senderBuf = serializeStringParam(obj.sender);
    var purposeBuf = serializeStringParam(JSON.stringify(obj.purpose));
    return Buffer.concat([buf, senderBuf, purposeBuf]);
};

/*
    DistributionKey Format
    {
        absValidity: /UIntBE, DIST_KEY_EXPIRATION_TIME_SIZE Bytes, Date() format/, // for absolute validity period
        val: /Buffer/
    }
*/
exports.parseDistributionKey = function(buf) {
    var absValidity = new Date(buf.readUIntBE(0, DIST_KEY_EXPIRATION_TIME_SIZE));
    var curIndex = DIST_KEY_EXPIRATION_TIME_SIZE;
    var cipherKeySize = buf.readUInt8(curIndex);
    curIndex += 1;
    var cipherKeyVal = buf.slice(curIndex, curIndex + cipherKeySize);
    curIndex += cipherKeySize;
    var macKeySize = buf.readUInt8(curIndex);
    curIndex += 1;
    var macKeyVal = buf.slice(curIndex, curIndex + macKeySize);
    return {
        cipherKeyVal: cipherKeyVal,
        macKeyVal: macKeyVal,
        absValidity: absValidity
    };
};

/*
    SessionKey Format
    {
        id: /UIntBE, SESSION_KEY_ID_SIZE Bytes/,
        absValidity: /UIntBE, SESSION_KEY_EXPIRATION_TIME_SIZE Bytes, Date() format/, // for absolute validity period
        relValidity: /UIntBE, REL_VALIDITY_SIZE Bytes, integer in millisecons/, // for relative validity period
        val: /Buffer/
    }
*/
function parseSessionKey(buf) {
    var keyId = buf.readUIntBE(0, exports.SESSION_KEY_ID_SIZE);
    var curIndex = exports.SESSION_KEY_ID_SIZE;

    var absValidity = new Date(buf.readUIntBE(curIndex, SESSION_KEY_EXPIRATION_TIME_SIZE));
    curIndex += SESSION_KEY_EXPIRATION_TIME_SIZE;
    var relValidity = buf.readUIntBE(curIndex, REL_VALIDITY_SIZE);
    curIndex += REL_VALIDITY_SIZE;

    var cipherKeySize = buf.readUInt8(curIndex);
    curIndex += 1;
    var cipherKeyVal = buf.slice(curIndex, curIndex + cipherKeySize);
    curIndex += cipherKeySize;
    var macKeySize = buf.readUInt8(curIndex);
    curIndex += 1;
    var macKeyVal = buf.slice(curIndex, curIndex + macKeySize);
    curIndex += macKeySize;

    var sessionKey = {
        id: keyId,
        cipherKeyVal: cipherKeyVal,
        macKeyVal: macKeyVal,
        absValidity: absValidity,
        relValidity: relValidity
    };
    return {sessionKey: sessionKey, totalLen: curIndex};
};

/*
    SessionKeyReq (encrypted with Distribution Key) Format
    {
    	sender: /string/, (senderLen UInt8) should be plain text so that Auth can find distribution key
		enBuf: /Buffer/ SessionKeyReq (nonce included) encrypted with distribution key
    }
*/
exports.serializeSessionKeyReqWithDistributionKey = function(senderName,
    sessionKeyReq, distributionKey, distributionCryptoSpec) {
    var sessionKeyReqBuf = exports.serializeSessionKeyReq(sessionKeyReq);
    var encBuf = exports.symmetricEncryptAuthenticate(sessionKeyReqBuf, distributionKey, distributionCryptoSpec);

    // TEST: generating error in encrypted data
    //encBuf.writeUInt8(12, encBuf.length - 12);

    var senderBuf = new Buffer(senderName);
    var lengthBuf = new Buffer(1);
    lengthBuf.writeUInt8(senderBuf.length);
    return Buffer.concat([lengthBuf, senderBuf, encBuf]);
};

/*
    SessionKeyResp Format
    {
        replyNonce:    /Buffer/,
        cryptoSpec:    /JSON/ {cipher: 'AES-128-CBC', hash: 'SHA256'} stringified, 
        sessionKeyList: /UInt32BE for length and List of SessionKey's/
        // TODO: who you're talking to? if req included keyId=?
    }
*/
exports.parseSessionKeyResp = function(buf) {
    var replyNonce = buf.slice(0, AUTH_NONCE_SIZE);
    var bufIdx = AUTH_NONCE_SIZE;

    var ret = parseStringParam(buf, bufIdx);
    var cryptoSpec = JSON.parse(ret.str);
    bufIdx += ret.len;

    var sessionKeyListLength = buf.readUInt32BE(bufIdx);
    bufIdx += 4;

    var sessionKeyList = [];
    for (var i = 0; i < sessionKeyListLength; i++) {
        var ret = parseSessionKey(buf.slice(bufIdx));
        var sessionKey = ret.sessionKey;
        sessionKeyList.push(sessionKey);
        bufIdx += ret.totalLen;
    }
    return {replyNonce: replyNonce, cryptoSpec: cryptoSpec, sessionKeyList: sessionKeyList};
};

// verialbe length integer encoding
function numToVarLenInt(num) {
    var buf = new Buffer(0);
    while (num > 127) {
        var extraBuf = new Buffer(1);
        extraBuf.writeUInt8(128 | num & 127);
        buf = Buffer.concat([buf, extraBuf]);
        num >>= 7;
    }
    var extraBuf = new Buffer(1);
    extraBuf.writeUInt8(num);
    buf = Buffer.concat([buf, extraBuf]);
    return buf;
};

function varLenIntToNum(buf, offset) {
    var num = 0;
    for (var i = 0; i < buf.length && i < 5; i++) {
        num |= (buf[offset + i] & 127) << (7 * i);
        if ((buf[offset + i] & 128) == 0) {
            return {num: num, bufLen: i + 1};
            break;
        }
    }
    return null;
};

/*
    IoTSP (IoT Secure Protocol) Message
    {
        msgType: /UInt8/,
        payloadLen: /variable-length integer encoding/
        payload: /Buffer/
    }
*/
exports.serializeIoTSP = function(obj) {
    if (obj.msgType == undefined || obj.payload == undefined) {
        console.log('Error: IoTSP msgType or payload is missing.');
        return;
    }
    var msgTypeBuf = new Buffer(1);
    msgTypeBuf.writeUInt8(obj.msgType, 0);
    var payLoadLenBuf = numToVarLenInt(obj.payload.length);
    return Buffer.concat([msgTypeBuf, payLoadLenBuf, obj.payload]);
};

exports.parseIoTSP = function(buf) {
    var msgTypeVal = buf.readUInt8(0);
    var ret = varLenIntToNum(buf, 1);
    var payloadVal = buf.slice(1 + ret.bufLen);
    return {msgType: msgTypeVal, payloadLen: ret.num, payload: payloadVal};
};

/*
    SignedMsg Format
    {
        data: /Buffer/,
        signature: /Buffer/   RSA_KEY_SIZE
    }
*/
exports.signAndAttach = function(buf, privateKey, publicKeyCryptoSpec) {
    var sign = crypto.createSign(publicKeyCryptoSpec.sign);
    sign.update(buf);
    var signature = sign.sign(privateKey);

    return Buffer.concat([buf, signature]);
};

// returns {signature: buffer, data: buffer}
exports.parseSignedData = function(buf, publicKeyCryptoSpec) {
    var data = buf.slice(0, buf.length - publicKeyCryptoSpec.keySize);
    var signature = buf.slice(buf.length - publicKeyCryptoSpec.keySize);
    return {signature:signature, data: data};
};

// returns {verified: bool, buf: Buffer}
exports.verifySignedData = function(buf, publicKey, publicKeyCryptoSpec) {
    var ret = exports.parseSignedData(buf, publicKeyCryptoSpec);
    var verifier = crypto.createVerify(publicKeyCryptoSpec.sign);
    verifier.update(ret.data);
    if (!verifier.verify(publicKey, ret.signature, 'hex')) {
        return {verified: false};
    }
    return {verified: true, buf: ret.data};
};

//var RSA_KEY_SIZE = 256;       // 2048 bits
//var MAX_PUB_ENC_BYTES = RSA_KEY_SIZE - 42; // 256 Bytes - 42 Bytes OAEP Padding = max 214 Bytes

exports.publicEncryptAndSign = function(buf, pubDest, privateKey, publicKeyCryptoSpec) {
    var MAX_PUB_ENC_BYTES = publicKeyCryptoSpec.keySize - 11; // 256 Bytes - 11 Bytes PKCS#1 Padding = max 245 Bytes
    if (buf.length <= MAX_PUB_ENC_BYTES) {
        var encBuf = crypto.publicEncrypt({key: pubDest, padding: constants[publicKeyCryptoSpec.padding]}, buf);
        return exports.signAndAttach(encBuf, privateKey, publicKeyCryptoSpec);
    }
    else {
        throw "Data for public encryption is too big!"
    }
};

exports.getPublicEncryptedAndSignedMessageSize = function(publicKeyCryptoSpec) {
    return publicKeyCryptoSpec.keySize * 2;     // only for RSA
}

exports.privateDecrypt = function(buf, privateKey, publicKeyCryptoSpec) {
    if (buf.length <= publicKeyCryptoSpec.keySize) {
        return crypto.privateDecrypt({key: privateKey, padding: constants[publicKeyCryptoSpec.padding]}, buf);
    }
    else {
        throw "Data for private decryption is too big!"
    }
};

// update current symmetric key with key derived from Diffie-Hellman key exchange
exports.updateSymmetricKeyWithKeyFromDH = function(symmetricKeySet, newSymmetricKeyValue) {
    var cipherKeyLength = symmetricKeySet.cipherKeyVal.length;
    var macKeyLength = symmetricKeySet.macKeyVal.length;
    // to copy other key information (e.g., validity periods)
    var newSymmetricKeySet = symmetricKeySet;
    newSymmetricKeySet.cipherKeyVal = newSymmetricKeyValue.slice(0, cipherKeyLength);
    newSymmetricKeySet.macKeyVal = newSymmetricKeyValue.slice(cipherKeyLength, cipherKeyLength + macKeyLength);
    return newSymmetricKeySet;
}

var HS_NONCE_SIZE = 8;            // default handshake nonce size

// generate handshake nonce
exports.generateHSNonce = function() {
    return crypto.randomBytes(HS_NONCE_SIZE);
};

/*
    Handshake Format
    {
        indicator: /UInt8/, // ind[0] = nonce?, ind[1] = replyNonce?, ind[2] = dhParam?
        nonce: /Buffer/, // encrypted, may be undefined
        replyNonce: /Buffer/, // encrypted, may be undefined,
        dhParam: /Buffer/, // Diffie-Hellman parameter (optional)
    }
*/
exports.serializeHandshake = function(obj) {
    if (obj.nonce == undefined && obj.replyNonce == undefined) {
        console.log('Error: handshake should include at least on nonce.');
        return;
    }

    var buf = new Buffer(1 + HS_NONCE_SIZE * 2);

    // indicates existance of nonces
    var indicator = 0;
    if (obj.nonce != undefined) {
        indicator += 1;
        obj.nonce.copy(buf, 1);
    }
    if (obj.replyNonce != undefined) {
        indicator += 2;
        obj.replyNonce.copy(buf, 1 + HS_NONCE_SIZE);
    }
    if (obj.dhParam != undefined) {
        indicator += 4;
        buf = Buffer.concat([buf, obj.dhParam]);
    }

    buf.writeUInt8(indicator, 0);

    return buf;
};

// buf should be just the unencrypted part
exports.parseHandshake = function(buf) {
    var obj = {};
    var indicator = buf.readUInt8(0);
    if ((indicator & 1) != 0) {
        // nonce exists
        obj.nonce = buf.slice(1, 1 + HS_NONCE_SIZE);
    }
    if ((indicator & 2) != 0) {
        // replayNonce exists
        obj.replyNonce = buf.slice(1 + HS_NONCE_SIZE, 1 + HS_NONCE_SIZE * 2);
    }
    if ((indicator & 4) != 0) {
        obj.dhParam = buf.slice(1 + HS_NONCE_SIZE * 2);
    }
    return obj;
};